using Components.Aphid.Tests.Integration;
using Components.Aphid.Tests.Integration.Shared;

global;
lastException;
success;
fault;
getTestKeys;
runTests;
isStandalone;
throw;

global = this;
lastException = null;

getTestKeys = @{
    k;
    i;
    s;
    s = this.{'$parent'};
    k = s |> keys |> Enumerable.ToList;
    i = 'tests' |> k.IndexOf;

    if (i == -1) {
        ret [];
    }

    ret Enumerable.Skip(k, i + 1)
        -? (@(x)
            !x.StartsWith('$') &&
            s.{x} != null &&
            s.{x}.GetType() == typeof(AphidFunction))
        |> Enumerable.ToArray;
};

@{
    #'Std';
    #'Meta';
    _try = macro(@(expectSuccess) {
        @() @{
            global.lastException = null;
            try $_();
            catch (e) {
                global.lastException = e;
                ret !expectSuccess;
            }

            ret expectSuccess
        }
    });
    success = _try(true);
    fault = _try(false);

    using System.IO;
    exe = getExe();
    isStandalone = !String.IsNullOrEmpty(exe) && Path.GetFileName(exe).ToLower() == "aphid.exe";

    if (isStandalone) {
        head('Aphid Test Framework');

        makeAssert;
        makeAssert = @(f) f @> @() $_ ? $_ : throw();
        global.isFoo = makeAssert(@== 'foo');
        global.is9 = makeAssert(@== 9);
        global.isNull = makeAssert(@== null);
        global.notNull = makeAssert(@!= null);

        this.{'$frames'}[0].Scope.{'$block'}.AddRange(@{ runTests() });
    }

    throw = @{
        #'IL';
        @{
            Newobj(typeof(InvalidOperationException).GetConstructor([ ]));
            Throw;
        } |> execIL;
    };

    runTests = @{
        testKeys;
        testResults;

        printQuery('Searching for tests');
        testKeys = getTestKeys();

        printSuccess('Found ~Cyan~{0}~R~ tests:\r\n', testKeys.Length);
        testKeys->@format('  ~Cyan~-~R~ {0}') @join('\r\n') |> print;
        print();

        printInfo('Executing tests');
        testResults = testKeys->@(k) {
            r;
            r = { key: k, func: this.{k}, result: null, success: true };

            printQuery('Running test ~Magenta~{0}~R~', k);

            try {
                r.result = r.func();

                if (Environment.UserInteractive && !Console.IsOutputRedirected) {
                    len = format('Running test {0}', k).Length;
                    Console.CursorTop = Console.CursorTop - 1;
                    Console.CursorLeft = len + 4;
                }

                if (r.result == null || r.result.GetType() != typeof(Boolean) || r.result) {
                    print(' -> ~Green~Successful~R~');
                } else {
                    r.success = false;
                    print(' -> ~Red~Unsuccessful~R~');
                    printError('Failed with return value: ~Yellow~{0}~R~', r.result |> serialize);

                    if (global.lastException != null) {
                        print(
                            '    Underlying exception: ~Yellow~{0}~R~',
                            global.lastException.message);

                            //global.lastException.exception |> print;
                    }
                }
            } catch (e) {
                printError('Test faulted: {0}', e.message);
                print(e.stack);
                r.error = e;
                r.success = false;
            }

            ret r;
        };

        var failed = testResults=?@()!$_.success;

        (failed ? printCriticalError : printSuccess)(
            'Done, ~{0}~{1:n0}/{2:n0}~R~ tests succeeded',
            failed ? 'Red' : 'Green',
            testResults-?(@.success) |> Enumerable.Count,
            testResults |> Enumerable.Count);
    };

}();

tests;
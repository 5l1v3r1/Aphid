
#'Std';
#'Meta';
#'Query';
#'Reflection';

using System.Linq;
isObj = reflection.members @> Enumerable.Any;

isCollection = @(x)
    x != null &&
    !isObj(x) &&
    x.GetType() != typeof(String) &&
    x.GetType().GetInterface('IEnumerable') != null;

getToken = @(text) (new AphidLexer(text)).GetTokens()[0].TokenType;

using System.Linq;

extend AphidExpression {
    is: @(x, type) x.Type == evalExp('AphidExpressionType.' + getIdArg(0) + 'Expression'),
    isCall: @(x) x.is(Call),
    isId: @(x) x.is(Identifier),
    isUnOp: @(x) x.is(UnaryOperator),
    isBinOp: @(x) x.is(BinaryOperator),

    isOp: @(x, op) (x.isUnOp() || x.isBinOp()) && x.op() == op,

    isParent: @(x) x.GetType().GetMethod('GetChildren') != null,
    
    oneAttr: @(x, a) x.attrs().Count == 1 && x.attr(0).id() == getIdArg(0),
    firstAttr: @(x, a) x.attrs().Count >= 1 && x.attr(0).id() == getIdArg(0),
    noAttrs: @(x) x.attrs().Count == 0,
    
    id: @(x) x.Identifier,
    func: @(x) x.FunctionExpression,
    args: @(x) x.Args,
    op: @(x) x.Operator,

    attr: @(x, i) x.attrs().Count >= 1 + i ? x.attrs()[i] : null,
    attrs: @(x) x.isId() ? x.Attributes : null,
    attrIds: @(x) x.attrs()->@(y)y.id(),
    body: @(x, i) !x.is(Function) || x.Body.Count <= i ? x : x.Body[i],    
    hasHeader: @(x, h) getArg(0).matchId(x.body(0)),

    matchId: @(x, y)
        x.isId() &&
        y.isId() &&
        x.id() == y.id() &&
        Enumerable.SequenceEqual(x.attrIds(), y.attrIds())
}

extend AphidExpression {
    isVba: @(x) x.hasHeader(As VBA),
    isSubStart: @(x) x.isCall() && x.func().isId() && x.func().oneAttr(Sub),
    getSubName: @(x) x.func().id(),
    isSubEnd: @(x) x.isId() && x.oneAttr(End) && x.id() == 'Sub',
}


10 |> isObj |> Console.WriteLine;
o = ({ x: 10 });



{ } |> isObj |> print;
// exit(0);

//isObj = @() $_ |> reflection.members 

cls();

using Components.External.ConsolePlus;
using System;
format = String.Format;

dump = serialize @> Console.WriteLine;




_t = @() Cli.WriteLine('~Magenta~Printing {0}~R~', [ $_ ]);
printp = @(fmt, arg0, arg1, arg2, arg3) {
    if ($args.Count >= 1 && fmt == null) {
        1 + 1;
        _null Cli.WriteLine('null', []);
    } else if ($args.Count > 1 && isCollection(fmt)) {
        _t('formatted collection');
        args = $args @aq.skip(1);
        for (x in fmt) {
            Cli.WriteLine(x.ToString(), args);
        }
    } else {
        switch ($args.Count) {
            0: {
                _t('blank line');
                Cli.WriteLine();
            }
            1: {
                if (isObj(fmt)) {
                    _t('serialized object');
                    Cli.WriteLine(fmt |> serialize |> Cli.Escape, []);
                } else if (isCollection(fmt)) {                    
                    _t('collection');
                    fmt->@() Cli.WriteLine($_.ToString(), []);
                } else {
                    _t('scalar');
                    Cli.WriteLine(fmt.ToString(), []);
                }
            }
            2: {
                
                if (arg0 |> isCollection) {
                    _t('formatted collection');
                    Cli.WriteLine(
                        fmt.ToString(),
                        arg0->@()$_.ToString());
                } else {
                    _t('single format arg');
                    args = $args @aq.skip(1);
                    Cli.WriteLine(fmt.ToString(), [ args0 ]);
                }
            }
            default: {
                _t('variadic formatted');
                args = $args @aq.skip(1);
                Cli.WriteLine(fmt.ToString(), args);
            }
        }
    }
};

head = @(msg){ Cli.WriteHeader($_, '~|Blue~~White~') };
header = head;

lastCall = null;
lastCallParent = null;
lastBlock = null;
lastBlockParent = null;
lastNode2 = null;
lastNode = null;
lastParent = null;
lastParent2 = null;
lastParent3 = null;
printp.Body @ast.walk(@(node, context) {
    if (
        !context.isBlock &&
        !context.isRoot &&
        node.isId() &&
        node.id() == 'Cli' &&
        node.attrs().Count >= 1) {
        msg = node
            .attrIds()
            ->(@() $_.StartsWith('_') ? $_.Substring(1) : $_)
            +>(@(x, y) x + ' ' + y);
        
        header('foo');

        for (s in context.stack){
            //printp(s);
            if (s |> isCollection) {
                printp('Collection: {0}', s)
            }

            if (s @has('Type')) {
                printp(s.Type + ' ' + s);
            } else {
                printp(s);
            }
        }
        printp('done');
        exit(0);

        prev = null;

        list = context.stack @aq.first(@(x) {
            if (x.GetType().Name.StartsWith('List')) {
                ret true;
            } else {
                prev = x;
                ret false;
            }
        });

        list.IndexOf(prev) |> print;

        list.GetType() |> printp;
        prev.GetType() |> printp;

        parseExp(format('_t("{0}")', msg)) |> print;
        
        // lastParent3 |> print;
        // lastParent3.Type |> printp;
        // lastBlockParent |> printp;
        // lastBlockParent |> dumpMembers;
        exit(0);
        // lastBlock |> print;
        // lastBlock |> dumpFuncs;
        // lastBlock.IndexOf(node) |> print;
        
        
        print(msg);
    }
    
    if (context.isBlock) {
        lastBlock = node;
        lastBlockParent = lastNode;
    }
    if (!context.isBlock && !context.isRoot) {
        if (node.isCall()) {
            lastCall = node;
            lastCallParent = lastParent2;
        }

        

        // if (node.GetType().GetMethod('GetChildren') != null &&
        //     (node.GetChildren() |> Enumerable.Any) > 0) {
        //     lastParent2 = lastParent;
        //     lastParent = node;
        // }
    }

    if (context.hasChildren) {
        lastParent3 = lastParent2;
        lastParent2 = lastParent;
        lastParent = node;
    }

    lastNode2 = lastNode;
    lastNode = node;

    
});
exit(0);
cls();
printp('Hello world');
printp();
printp(false);
printp(null);
printp([ ]);
printp([1, 2, 3, 4 ]);
printp({ foo: 10 });
// printp([ 1, 2, 3 ], [10, 20]);
// printp('~Yellow~foo~R~ {0} {1}', 'foo', 'bar');
// printp('done {1}, {2}', [ 1, 2, 3 ]);
// printp('done {0} {1}, {2}', 1, 2, 3);
exit(0);


exit = @(code) {
    head('Frames');
    frames = this.{'$frames'};
    frames.Count |> printp;
    args = 0..frames.Count->@() [
        frames[$_].Name,
        Cli.Escape(frames[$_].Expression.ToString())
    ];
    args @printp('Member: ~Yellow~{0}~R~\r\n{1}');
    Environment.Exit(0);
};



hr = @() printp('-' * 40);


dumpMethods =
    Cli
    |> typeof
    @() $_.GetMethods()
    -?(@(x) x.Name == 'Dump');

dumpMethod = dumpMethods[1].MakeGenericMethod([ String |> typeof ]);
dumpMethods == null |> printp;
dumpMethod.Invoke(null, [ 'foo' ]);
// dumpMethod |> getFuncs -? (@()$_.Name.Contains('Gener')) ->print;
//dumpMethod.Invoke('foo', [ 'foo' ]);
exit(0);



exit(0);

head('foo');
x = print;
printp |> dumpMembers;

x |> dumpProps;
i = 0x100;
Array.Resize(printp.Args, 0x100);
0..0x10 ->@{ i++ @format('o{0}') |> parse |> printp.Args.Add };

exit(0);


exit(0);
@{
    As VBA;

    Debug.Print('[#] Starting');
    
    Sub GreetUser(Name);
        MsgBox("Hello " & Name & "!");
    End Sub;

    Sub LogAdminActivity();
        Debug.Print('[#] Log activity 1');
        LogAdminActivity2();
    End Sub;

    Sub LogAdminActivity2();
        Debug.Print('[#] Log activity 2');
    End Sub;
    
    Sub TestGreet();
        Name = InputBox('Enter Name', DefaultResponse:='John');
        Debug.Print('[?] Validate user input');

        If Not Name = vbNullString Then;
            GreetUser(Name);
        End If;
        
        Debug.Print('[?] Check if user {0} is admin', Name);
        Admin = "John";

        If Name = Admin Then;
            Debug.Print('[+] User is admin');
            LogAdminActivity();
        Else;
            Debug.Print('[-] User is not admin');
            Moderator = "Bob";


            Debug.Print('[?] Check if user {0} is mod', Name);
            If Name = Moderator Then;
                Debug.Print('[+] User is moderator');
            End If;

        End If;
    End Sub;    

    TestGreet();

    ExpectedDepth = 0;
    Debug.Print('[?] Assert depth is {0}', ExpectedDepth);
    
    If Depth = ExpectedDepth Then;
        Debug.Print('[+] Depth is expected value');
    End If;

    Debug.Print('[#] Done');
};

vbNullString = "";

load System.Windows.Forms;
using System.Windows.Forms;
MsgBox = MessageBox.Show;

load Microsoft.VisualBasic;
using Microsoft.VisualBasic;

InputBox = Interaction.InputBox;

Depth = 0;
Indent = @() (++Depth) * '';
Unindent = @() (Depth--) * '';
Margin = @() Depth * '    ';

using System;
using Components.External.ConsolePlus;
Debug = {
    Print: @() {
        switch ($args.Count) {
            0: Cli.WriteLine();
            1: Cli.WriteLine(Margin() + $_, []);
            default: Cli.WriteLine(Margin() + $_, $args @aq.skip(1));
        }
    }
};



root = this.{'$scope'};
vbaContext = { sub: null, nodes: [], };

evalVbaBlocks = @{
    getVbaBlocks() 
        -> @(b) [
            replaceAndOperators,
            replaceNamedArguments,
            replaceIf,
            parseVbaBlock
        ] 
        -> @()$_(b);
    
    print('Done parsing, evaluating VB\r\n');    
    [
        
        instrumentBlocks,
        evalAst 
    ]->@() vbaContext.nodes |> $_;
};

getVbaBlocks = @() this.{'$parent'}.{'$block'}-?@(x) x.isVba();

replaceIf = @(block){
    head('Replace if');

    
    op = getToken('=');
    lastStatement = null;

    ifContext = {
        inIf: false,
        inElse: false,
        depth: 0,
        negate: false,
        condition: null,
        ifBody: null,
        elseBody: null,
        nested: false,
        nodes: [],
        statements: [],
        children: [],
    };

    ifContext |> dump;
    this |> dump;
    // ifContext |> serialize |> print;
    
    block @ast.walk(@(node, context) {
        // print(node);

        if (node.GetType().GetProperty('Body') != null &&
            node.is(Function)) {
            ifContext.children.add(node);
            ifContext |> dump;
            // exit(0);
        }
        if (context.isBlock && ifContext.depth > 0) {
            print('-'*80);
            node |> dumpProps;exit(0);
        }

        if (context.isRoot || context.isBlock) {
            ret null;
        }

        addNode = @(n){
            if (ifContext.inIf || ifContext.inElse) {
                fatal('Cannot add in if');
            }

            ifContext.nodes.add(n);
            context.isHandled = true;
        };

        addBodyNode = @(n) {
            if (!ifContext.inIf && !ifContext.inElse) {
                fatal('Cannot add outside if');
            }

            if (!ifContext.inElse) {
                n @print('~|White~~Blue~[If]~R~ {0}');
                ifContext.ifBody.add(n);
            } else {
                n @print('[Else] {0}');
                ifContext.elseBody.add(n);
            }
            
            context.isHandled = true;
        };        

        if (node.isBinOp() &&
            node.isOp(op) &&
            node.LeftOperand.isId() &&
            node.LeftOperand.firstAttr(If) &&
            node.RightOperand.id() == 'Then') {
            
            if (!ifContext.inIf) {
                print('[+] Beginning If');
                ifContext.inIf = true;
                ifContext.ifBody = [];
                ifContext.elseBody = [];
                attrs = node.LeftOperand.attrIds();
                attrs.Reverse();            
                stack = new Stack(attrs);
                stack.Pop();

                switch (stack.Count) {
                    0: {}
                    1: {
                        p = stack.Pop();

                        if (p == 'Not') {
                            ifContext.negate = true;
                        } else {
                            fatal('Invalid If modifier: {0}', p);
                        }
                    }                
                    default: {
                        fatal('Too many If modifiers');
                    }
                }

                node.LeftOperand.attrs().Clear();
                
                ifContext.condition = new BinaryOperatorExpression(
                    node.LeftOperand,
                    getToken(!ifContext.negate ? '==' : '!='),
                    node.RightOperand.attrs()[0]);

                context.isHandled = true;
            } else {
                ifContext.depth++;
                ifContext.nested = true;
                addBodyNode(node);                
            }
        } else if (node.isId() && node.noAttrs() && node.id() == 'Else') {
            if (!ifContext.inIf || ifContext.inElse) {
                fatal('Unexpected Else');
            }

            print('[+] Else');

            ifContext.inElse = true;
            context.isHandled = true;
        } else if (node.isId() && node.oneAttr(End) && node.id() == 'If') {
            if (!ifContext.inIf) {
                fatal('Unexpected End If');
            }

            if (ifContext.depth == 0) {
                print('[+] End If');                        
                t = parse('if(0){}else{}')[0];
                ifContext.ifBody->t.Body.Add;
                ifContext.elseBody->t.ElseBody.Add;
                
                ifExp = new IfExpression(
                    ifContext.condition,
                    t.Body,
                    t.ElseBody);

                ifContext.inIf = false;
                ifContext.inElse = false;
                ifContext.depth = 0;
                ifContext.negate = false;
                ifContext.condition = null;
                ifContext.ifBody = null;     
                ifContext.elseBody = null;                
                addNode(ifExp);
                ifContext.statements.add(ifExp);
            } else {
                print('[i] Nested');
                ifContext.depth--;
                addBodyNode(node);
            }
        } else if (ifContext.inIf){
            node @print('[B] Node: {0}');
            addBodyNode(node);
        } else {
            node @print('[N] Node: {0}');
            addNode(node);
        }
    });

    

    block.Body.Clear();
    ifContext.nodes->block.Body.Add;
    
    if (ifContext.nested) {
        ifContext.children->replaceIf;
        // exit(0);
        //$_ |> ;
        // print('-0'*40);
        // print('Isnested2');
        // exit(0);
        // p.Body @ast.walk(@(node, context) {
            // print('-0'*40);
            //     print(node);
            // if (context.isRoot) {
                // print('Root');
            // } else if (!context.isBlock) {
                // if (ast.depth < 0x1) {
                //     print('{0}{1}\r\n{0}{2}',
                //         ast.indent(),
                //         node.Type.ToString(),
                //         node.ToString());
                // } else {
                    // node.ToString() |>print;
                    // print('{0}{1}',
                    //     ast.indent(),
                    //     node.Type.ToString());
                //}
            // }
        // });
        // exit(0);
        // print('-'*40);
        
        // exit(0);
    }
    // exit(0);

    // ifContext.nodes @ast.walk(@(node, context) {
    //     if (context.isRoot) {
    //         print('Root');
    //     } else if (!context.isBlock) {
    //         if (ast.depth < 0x101) {
    //             print('{0}{1}\r\n{0}{2}',
    //                 ast.indent(),
    //                 node.Type.ToString(),
    //                 node.ToString());
    //         } else {
    //             print('{0}{1}',
    //                 ast.indent(),
    //                 node.Type.ToString());
    //         }
    //     }
    // });
};



replaceAndOperators = @{
    print('-' * 40);
    print('[R] Replacing & operators');

    $_.Body @ast.walk(@(node, context) {
        if (!context.isRoot &&
            !context.isBlock) {
            //print(node);
        }

        if (!context.isRoot &&
            !context.isBlock &&
            node.is(BinaryOperator) &&
            node.Operator == AphidTokenType.BinaryAndOperator) {
            
            @print('[+] Replacing & operator in expression {0}', node);
            using System.Reflection;
            
            node
                .GetType()
                .GetField('_operator', BindingFlags.NonPublic | BindingFlags.Instance)
                .SetValue(node, AphidTokenType.AdditionOperator);
        }
    })
};

replaceNamedArguments = @{
    #'Reflection';
    using System.Collections;            
    op = getToken(':=');
    
    $_.Body @ast.walk(@(node, context) {
        if (!context.isRoot &&
            !context.isBlock &&
            node.is(Call) &&
            node.func().isId() &&
            node.func().id() == 'InputBox') {

            argObj = {
                Prompt: parseExp("''"),
                Title: parseExp("''"),
                DefaultResponse: parseExp("''"),
                XPos: parseExp("-1"),
                YPos: parseExp("-1")
            };

            params = argObj |> reflection.members;
            params.Reverse();
            stack = new Stack(params);

            node.args()->@{                
                if ($_.isId()) {
                    argObj.{stack.Pop()} = $_.ToString();
                } else if ($_.isBinOp()) {
                    if ($_.Operator != op) {
                        fatal('Unexpected operator: {0}', $_.Operator);
                    }

                    argObj.{$_.LeftOperand} = $_.RightOperand;                    
                } else {
                    argObj.{stack.Pop()} = $_;
                }
            };

            node.args().Clear();
            argObj |> reflection.members ->@{ node.args().Add(argObj.{$_}); };
            
            context.isHandled = true;
        }
    })
};

parseVbaBlock = @{
    inHeader = true;
    $_.Body @ast.walk(@(node, context) {
        if (context.isRoot || context.isBlock) {
            ret null;
        } else if (inHeader) {
            inHeader = false;
            context.isHandled = true;

            ret null;
        } else if (node.isSubStart())  {
            if (vbaContext.sub != null) {
                fatal('Unexpected Sub, already in {0}', vbaContext.sub);
            }

            vbaContext.sub = node.getSubName();
            print('Parsing Sub: {0}', vbaContext.sub);
            
            print('Validating Sub arguments');
            badParams = node.Args-?@() !$_.isId();

            if (badParams.Count != 0) {
                fatal('Expected identifiers for Sub params');
            }            
            
            vbaContext.subBody = [];
            vbaContext.subArgs = node.Args;
            root.{vbaContext.sub} = null;
            context.isHandled = true;
        } else if (vbaContext.sub != null && !node.isSubEnd()) {
            vbaContext.subBody.add(node);
            context.isHandled = true;
        } else if (node.isSubEnd()) {
            if (vbaContext.sub == null) {
                fatal('Unexpected End Sub');
            } 

            funcDecl = vbaContext.sub @String.Format('{0} = @(){{}}') |> parseExp;
            vbaContext.subArgs->funcDecl.RightOperand.Args.Add;
            vbaContext.subBody->funcDecl.RightOperand.Body.Add;
            vbaContext.nodes.add(funcDecl);            
            
            print('Ending sub: {0}', vbaContext.sub);
            vbaContext.sub = null;
            context.isHandled = true;
        } else {
            vbaContext.nodes.add(node);
            context.isHandled = true;
        }
    })
};


instrumentBlocks = @{
    lastId = null;
    $_ @ast.walk(@(node, context) {
        if (context.isRoot || context.isBlock) {
            ret null;
        } else if (node.isId()) {
            lastId = node.id();
        } else if (node.is(Function) &&
            lastId != 'Margin' &&
            lastId != 'Indent' &&
            lastId != 'Unindent') {
            lastId @print('Instrumenting {0}');
            node.Body.Insert(
                0,
                parse(
                    lastId @String.Format(
                        "Debug.Print('[~Cyan~>~R~] Entering ~Cyan~{0} Sub~R~')"))[0]);

            node.Body.Insert(1, parseExp('Indent()'));

            node.Body.Add(
                parse(
                    lastId @String.Format(
                        "Debug.Print(Unindent() + '[~Cyan~<~R~] Exiting ~Cyan~{0} Sub~R~')"))[0]);
            
        } else if (node.is(If)) {
            n = node.Condition.LeftOperand.id();
            
            node.Body.Insert(
                0,
                parse(
                    n @String.Format(
                        "Debug.Print('[~Cyan~>~R~] Entering ~Cyan~If {0} Body~R~')"))[0]);

            node.Body.Insert(1, parseExp('Indent()'));

            node.Body.Add(
                parse(
                    n @String.Format(
                        "Debug.Print(Unindent() + '[~Cyan~<~R~] Exiting ~Cyan~If {0} Body~R~')"))[0]);

            if (node.ElseBody.Count > 0) {
                node.ElseBody.Insert(
                    0,
                    parse(
                        n @String.Format(
                            "Debug.Print('[~Cyan~>~R~] Entering ~Cyan~Else {0} Body~R~')"))[0]);

                node.ElseBody.Insert(1, parseExp('Indent()'));

                node.ElseBody.Add(
                    parse(
                        n @String.Format(
                            "Debug.Print(Unindent() + '[~Cyan~<~R~] Exiting ~Cyan~Else {0} Body~R~')"))[0]);
            }
        }
    })
};

evalVbaBlocks();


    

//#'DebugDeploy';
#'Std';
#'Meta\\Code\\Generation\\IL';
#'System\\Nuget';
using Components.Aphid.Interpreter;
using System.IO;
using System.Diagnostics;
using System.Reflection;
using System.Reflection.Emit;
head('MakeExe');

var args = parseArgsFor(
    [ 'run.exe', 'run.alx', 'run' ], 
    [ 'makeexe.exe', 'makeexe.alx', 'makeexe' ]);

var usage = 'MakeExe [script name] {exe name}';

if (args.Count == 0) {
    print(usage);
    exit(0);
//} else if (args.Count != 1 && args.Count != 2) {
}

var script = args[0].Value | Path.GetFullPath;
var scriptDir = script | Path.GetDirectoryName;

var asmName = args.Count >= 2 ?
    args[1].Value :
    Path.ChangeExtension(args[0].Value, 'exe');

var extraRefs = args.Count >= 3 ? args @aq.skip(2) -> @.Value : [];

var pdbFile = Path.ChangeExtension(asmName, 'pdb');
[ pdbFile, asmName ]-?File.Exists->File.Delete;

var properties = {
    name: asmName |> Path.GetFileName,
    path: asmName,
    title: asmName |> Path.GetFileNameWithoutExtension,
    version: '1.0.0.0',
    showConsole: true,
};

printInfo('Parsing script');
var scriptAst = script |> AphidParser.ParseFile;

if (scriptAst.Count >= 0 && scriptAst[0].GetType() == ObjectExpression) {
    var p = scriptAst[0] |> evalNode;
    p |> keys -> @() properties.{$_} = p.{$_};
}

printInfo('Starting preprocessing');
var partialOpMutator = new PartialOperatorMutator();
var macroMutator = new AphidMacroMutator();
var directiveMutator = new AphidPreprocessorDirectiveMutator();
var includeMutator = new IncludeMutator(scriptDir);
//includeMutator.PerformCommonTransformations = false;
var constantFoldingMutator = new ConstantFoldingMutator();

var srcAst = scriptAst
    |> partialOpMutator.Mutate
    |> macroMutator.Mutate
    |> directiveMutator.Mutate
    |> includeMutator.Mutate
    |> constantFoldingMutator.Mutate;

printSuccess('Preprocessing complete');

printInfo('Creating projecting into bytecode', byteCodeFile);
var byteCode = srcAst |> AphidByteCode.Encode;
printSuccess('Projected into ~Cyan~{0:n0}~R~ byte stream', byteCode.Length);
properties.streams = { ByteCode: new MemoryStream(byteCode) };
printInfo('Assembly attributes:');
properties |> keys -> @() print('    [{0}] ~White~{1}~R~', $_, properties.{$_});
print();

printInfo('Creating module {0} for {1}', asmName, script);

importOpcodes();
@{
    var e = $_.Emit;
    $_.DeclareLocal(AphidInterpreter);
    e(Newobj, AphidInterpreter.GetConstructor([]));
    e(Stloc_0);

    e(Ldloc_0);
    e(Ldstr, script);
    e(Call, AphidInterpreter.GetMethod('SetScriptFilename', [ string ]));    

    e(Ldloc_0);
    e(Ldstr, 'ByteCode');
    e(Call, AphidByteCode.GetMethod('DecodeResource'));
    
    e(Call, AphidInterpreter.GetMethod('Interpret', [ List[AphidExpression] ]));
    e(Ret);
}
@createProgram(properties);

installPackage('ilmerge');

var ilMergeBin =
    'packages'
    |> getEntryPath
    @() Directory.EnumerateFiles($_, 'ilmerge.exe' ,SearchOption.AllDirectories)
    |> Enumerable.FirstOrDefault;

// var ilMergeBins = Directory.GetFiles(
//     '.\\',
//     'ilmerge.exe',
//     SearchOption.AllDirectories);

if (ilMergeBin == null) {
    printError('Could not find ilmerge.exe');
    exit(0xbad81);
}

var asm = load ilMergeBin;

if (asm != null) {
    printSuccess('Loaded ~Cyan~{0}~R~:\r\n    {1}', asm, asm.Location);
}

using ILMerging;

var il = new ILMerge();
il.Log = true;
il.LogFile = properties.path + '.ilmerge.txt';

if (il.LogFile | File.Exists) {
    il.LogFile | File.Delete;
}

var searchDirs = new List[string]();

[
    // 'C:\\windows\\Microsoft.NET\\Framework\\v4.0.30319',
    // 'C:\\windows\\Microsoft.NET\\Framework64\\v4.0.30319',
    'C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.7.2',
]->searchDirs.Add;

extraRefs-?Directory.Exists->searchDirs.Add;

if (searchDirs | Enumerable.Any) {
    il.SetSearchDirectories(searchDirs | Enumerable.ToArray);
}

// il.SetSearchDirectories([
//     'C:\\windows\\Microsoft.NET\\Framework\\v4.0.30319',
//     'C:\\windows\\Microsoft.NET\\Framework64\\v4.0.30319',
//     'C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.7.2',
// ]);

//il.dir();

il.SetTargetPlatform(
    'v4',
    'C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.7.2');

var extraAsms = new List[string]();
extraRefs-?(@()!searchDirs.Contains($_))->extraAsms.Add;

var inputAsms = 
    Enumerable.Concat([
        properties.path, AphidObject.Assembly.Location ],
        extraAsms | Enumerable.ToArray)
    | Enumerable.ToArray;

[
    [ 'Merging assemblies', inputAsms ],
    [ 'Setting seasrch directories' , searchDirs ]
]
->@(p) p[1] @join('\r\n    ') @printInfo('{0}:\r\n    {1}', p[0]);
inputAsms | il.SetInputAssemblies;



il.OutputFile = properties.path |> Path.GetFullPath;
printInfo('Merging into final binary ~Cyan~{0}~R~', il.OutputFile);
il.Merge();

printSuccess('Done');
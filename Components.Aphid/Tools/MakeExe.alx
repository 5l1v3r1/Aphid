//#'DebugDeploy';
#'Std';
#'Meta';
#'IL';
#'Nuget';
using Components.Aphid.Interpreter;
using System.IO;
using System.Diagnostics;
using System.Reflection;
using System.Reflection.Emit;

var args = Environment.GetCommandLineArgs()->@() $_;

if (args.Count >= 1) {
    var n = Path.GetFileName(args[0]).ToLower();

    if (n == 'aphid' || n == 'aphid.exe' || n == 'aphid.vshost.exe') {
        args = args @aq.skip(2);
    } else {
        args = args @aq.skip(1);
    }
}

var usage = 'MakeExe [script name] {exe name}';

if (args.Count == 0) {
    print(usage);
    exit(0);
} else if (args.Count != 1 && args.Count != 2) {
    fatal('Invalid arguments, expected {0}', usage);
}

var script = args[0];

var asmName = args.Count == 2 ?
    args[1] :
    Path.ChangeExtension(args[0], 'exe');

var properties = {
    name: asmName |> Path.GetFileName,
    path: asmName,
    title: asmName |> Path.GetFileNameWithoutExtension,
    version: '1.0.0.0',
    showConsole: true,
};

printInfo('Parsing script');

var scriptAst = script |> AphidParser.ParseFile;
if (scriptAst.Count >= 0 && scriptAst[0].GetType() == ObjectExpression) {
    var p = scriptAst[0] |> evalNode;
    p |> keys -> @() properties.{$_} = p.{$_};
}

printInfo('Inlining referenced scripts');
var partialOpMutator = new PartialOperatorMutator();
var macroMutator = new AphidMacroMutator();
var directiveMutator = new AphidPreprocessorDirectiveMutator();
var includeMutator = new IncludeMutator();

var srcAst = scriptAst
    |> partialOpMutator.MutateRecursively
    |> macroMutator.MutateRecursively
    |> directiveMutator.MutateRecursively
    |> includeMutator.MutateRecursively;

var byteCodeFile = Path.ChangeExtension(properties.path, 'alxb');
printInfo('Writing byte code to ~Cyan~{0}~R~', byteCodeFile);

srcAst |> AphidByteCode.Encode @File.WriteAllBytes(byteCodeFile);
var decoded = byteCodeFile |> File.ReadAllBytes |> AphidByteCode.Decode;
// decoded |> dumpe;


printInfo('Assembly attributes:');
properties |> keys -> @() print('    [{0}] ~White~{1}~R~', $_, properties.{$_});
print();

printInfo('Creating module {0} for {1}', asmName, script);

importOpcodes();

@{
    var e = $_.Emit;
    e(Ldc_I4_1);
    e(Newobj, AphidInterpreter.GetConstructor([ bool ]));
    e(Call, Assembly.GetMethod('GetExecutingAssembly'));
    e(Callvirt, Assembly.GetMethod('get_Location'));
    e(Call, Path.GetMethod('GetDirectoryName'));
    e(Ldstr, byteCodeFile |> Path.GetFileName);
    e(Call, Path.GetMethod('Combine', [ string, string ]));
    e(Call, File.GetMethod('ReadAllBytes'));
    e(Call, AphidByteCode.GetMethod('Decode'));
    e(Call, AphidInterpreter.GetMethod('Interpret', [ List[AphidExpression] ]));
    // e(Ldc_I4_0);
    // e(Call, AphidInterpreter.GetMethod('InterpretFile', [ string, bool ]));
    e(Ret);
}
@createProgram(properties);

installPackage('ilmerge');
load ".\\ilmerge.2.14.1208\\tools\\ILMerge.exe";
using ILMerging;

var il = new ILMerge();
il.SetInputAssemblies([
    properties.path,
    AphidObject.Assembly.Location
]);

il.OutputFile = properties.path;
il.Merge();

printSuccess('Done');
#'CodeDom';
#'Std';
#'Meta';
using Components.Aphid.UI;

// Used to ignore scripts copied to bin directory by build process. To
// disable, comment line out.
var ignorePattern = '\\bin\\';

var cliArgs = Environment.GetCommandLineArgs();

if (cliArgs.Length != 5) {
    print('aphid AphidExportStubCompiler.alx [namespace] [project dir] [output dir]');
    exit(1);
}

var namespace = cliArgs[2];
var projectDir = cliArgs[3];
var outputDir = cliArgs[4];

printInfo('Generating classes in namespace ~Cyan~{0}~R~', namespace);

if (!Directory.Exists(projectDir)) {
    printError('Could not find project directory ~Yellow~{0}~R~', projectDir);
    exit(0xbad01);
}

if (!Directory.Exists(outputDir)) {
    printInfo('Creating output directory ~Cyan~{0}~R~', outputDir);
    Directory.CreateDirectory(outputDir);
}

printQuery('Searching project directory for scripts');
var srcFiles = Directory.GetFiles(projectDir, '*.alx', SearchOption.AllDirectories)
    -?@() !(ignorePattern defined) || !$_.ToLower().Contains(ignorePattern);

if (srcFiles.Count == 0) {
    printError('No scripts found');
    exit(0xbad02);
}

printSuccess('Found ~Green~{0}~R~ script(s)', srcFiles.Count);

var export = {
    resolve: @(type) this.{'$aphid'}.InteropTypeResolver.ResolveType(
        this.{'$imports'}.ToArray(),
        [ type ],
        true,
        true),

    find: @(srcAst) {
        using System.Collections.Generic;
        var exports = new List[AphidObject]();

        srcAst @ast.walk(@(node, context) {
            if (!context.isRoot && !context.isBlock && node.isId() && node.firstAttr(export)) {
                var exportExp = context.stack
                    ->@.node
                    @aq.first(@(x)
                        x.GetType() == BinaryOperatorExpression &&
                        x.isOp(AphidTokenType.AssignmentOperator));

                var retType =
                    ($(node.attrs().Count) 1: 'void', node.attr(1).Identifier)
                    |> resolve;

                var memberPath = exportExp.lhs().GetChildren()->@.Identifier;
                var className = memberPath[0];
                var propertyName = memberPath[1];
                
                var params = exportExp.rhs().Args
                    ->@()({
                        type: ($_.noAttrs() ? 'AphidObject' : $_.attr(0).Identifier) |> resolve,
                        name: $_.Identifier
                    });

                {
                    retType,
                    className,
                    propertyName,
                    params,
                    func: exportExp.rhs()
                } |> exports.Add;
            }
        });

        ret exports;
    },

    generate: @(export) {
        
        var typeName = export.className;
        var delName = export.propertyName + 'Delegate';
        var fieldName = '_' + export.propertyName;
        var propName = export.propertyName;
        var f = code.field(code.typeExp(typeName), fieldName);

        var d = code
            .namespace(namespace)
            .type(typeName)
            .partial()
            .field(delName, fieldName)
                .static()
                .next()
            .withPublic()
            .property(delName, propName)
                .static()
                .getStmt(code.methodReturn(f))
                .setStmt(code.assign(f, code.var('value')))
                .next()
            .delegate(export.retType, delName);

        export.params->@() d.param($_.type, $_.name);

        ret d.next().namespace().code();
    }
};

srcFiles->@(srcFile) {
    printInfo('Parsing ~Cyan~{0}~R~', srcFile);
    var srcCode = srcFile |> File.ReadAllText;
    var srcAst;
    
    try {
        srcAst = srcCode |> parse;
    } catch (e) {
        AphidCli.DumpException(e.exception.InnerException, srcCode);
        ret null;
    }

    var cs = srcAst |> export.find -> export.generate @join('\r\n\r\n');

    if (cs.Trim() == '') {
        ret null;
    }
    
    var dstFile =
        Path.ChangeExtension(srcFile, 'cs')
        |> Path.GetFileName
        @Path.Combine(outputDir);

    printInfo('Writing compiled class to ~Green~{0}~R~', dstFile);
    cs @File.WriteAllText(dstFile);
    // cs |> print;
};

printSuccess('Done');
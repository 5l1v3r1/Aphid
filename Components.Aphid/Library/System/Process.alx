var system;
var startProcess;
var prepareCommand;

@{
    using Components;
    using System;
    using System.Diagnostics;
    using System.Threading;

    var _tp = traceProcess defined && traceProcess ? print : @{ };

    startProcess = @(exe, args, onLine, noWindow) {
        _tp('Starting process');
        var si = new ProcessStartInfo(exe, args);
        si.UseShellExecute = false;
        si.CreateNoWindow = noWindow defined ? noWindow : false;
        si.RedirectStandardOutput = true;
        si.RedirectStandardError = true;
        var proc = Process.Start(si);

        var procThread = new Thread(@{
            try {
                while (!proc.StandardOutput.EndOfStream) {
                    var line = proc.StandardOutput.ReadLine();

                    if (line == null) {
                        continue;
                    }

                    [ onLine, Console.WriteLine]->@(x)x(line);
                }
            } catch(e) {
                _tp('[x] Thread error: ~Yellow~{0}~R~', e.message);
            }
        });

        procThread.Start();

        _tp('[?] Waiting for thread');
        procThread.Join();
        _tp('[+] Done');

        ret proc;
    };

    system = @(cmd) cmd ~> print @() try $_.WaitForExit(); catch(e) { };

    prepareCommand = @(cmd)
        cmd == null ? null :
        !cmd.GetType().IsArray ? cmd |> ArgLexer.Tokenize |> prepareCommand :
        $(cmd.Length)
            0: null,
            [
                cmd[0],
                cmd @aq.skip(1) -> (@(x) x.Contains(' ') ? format('"{0}"', x) : x) @String.Join(' ')
            ];
}();

@ ~> (cmd, onLine) cmd |> prepareCommand @() startProcess($_[0], $_[1], onLine);

@ <# (cmd, onLine) {
    var sb = new StringBuilder();
    
    var proc = cmd
        |> prepareCommand
        @() startProcess($_[0], $_[1], sb.AppendLine, true);

    proc.WaitForExit();

    ret { proc, out: sb, exitCode: proc.ExitCode }
};

@ #> (cmd) {
    using System.Diagnostics;
    var c = cmd |> prepareCommand;
    var si = new ProcessStartInfo(c[0], c[1]);
    si.UseShellExecute = false;
    var p = Process.Start(si);
    p.WaitForExit();

    ret p.ExitCode;
};
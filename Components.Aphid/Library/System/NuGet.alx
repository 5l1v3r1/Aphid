var installPackage;
var nuget;

@{
    using Components.Aphid.TypeSystem;
    using System.Collections.Generic;   
    using System.Net;
    using System.Reflection;

    using NuGet;

    var parseVersion = @(v) $(v.GetType())
        SemanticVersion: v,
        string: v | SemanticVersion.Parse,
        throw new InvalidArgumentException('v');

    nuget = {
        exe: Path.Combine(AphidObject.Assembly.Location | Path.GetDirectoryName, 'nuget.exe'),
        exeUrl: 'https://dist.nuget.org/win-x86-commandline/latest/nuget.exe',

        init: @{
            if (!File.Exists(exe)) {
                'Could not find2 ~Cyan~{0}~R~, downloading ~Yellow~{1}~R~' :> [ exe, exeUrl ];
                (new WebClient()).DownloadFile(exeUrl, exe);
            } /*else {
                'Nuget assembly found at ~Green~{0}~R~' :> [ exe ];
            }*/

            if (load exe == null) {                
                throw 'Failed loading Nuget.Core';
            } /*else {
                :> 'Nuget assembly loaded';
            }*/
        },

        repoUrl: "https://packages.nuget.org/api/v2",
        customResolver: false,
        isResolveSet: false,
        trace: false,
        ignoreDependencies: false,
        allowPrereleaseVersions: true,
        refMap: new Dictionary[string, string](),
        createRepo: @() PackageRepositoryFactory.Default.CreateRepository(repoUrl),
        createPackageManager: @() new PackageManager(createRepo(), getEntryPath('packages')),
        getLocalPackages: @() createPackageManager().LocalRepository.GetPackages(),
        
        reference: @(packageId, version) {
            // if ($args.Count > 1) {
            //     ret $args-<reference;
            // }

            // printInfo('Referencing {0} {1}', packageId, version);

            var findPackage = @() version defined && version != null ?
                getLocalPackages() -? @(x) x.Id == packageId && x.Version == parseVersion(version) :
                getLocalPackages() -? (@(x) x.Id == packageId) -/ @.Version;

            var packages = findPackage();

            if (packages #! @== 0) {
                version defined ?
                    installPackage(packageId, version) :
                    installPackage(packageId);

                // getLocalPackages() -? (@(x) x.Id == packageId) |> dump;
                packages = findPackage();
            }

            var p = packages ^!;
            
            var fs = createPackageManager().FileSystem;
            var d = '{0}.{1}' :: [ p.Id, p.Version ] |> fs.GetFullPath;
            
            var refAsmGroups = p.AssemblyReferences
                -<(@(r) $_.SupportedFrameworks->(@()({
                    path: r, name: $_.FullName, version: $_.Version
                })))
                -&@.name;

            var filtered = refAsmGroups -? @() $_.Key.StartsWith('.NETFramework');

            var refAsmPaths = ((filtered #!) != 0 ? filtered : refAsmGroups)
                -/@.Key
                ^!
                ->@() Path.Combine(d, $_.path);

            var badAsms = refAsmPaths-?(@(x) !File.Exists(x));

            if (badAsms #! @!= 0) {
                    fatal('Bad asms: {0}', badAsms @join(', '));
                    exit(0xbad01);
            }

            refAsmPaths->@(a) {
                var key = a |> Path.GetFileNameWithoutExtension;
                traceInfo('Adding ~Magenta~{0}~R~:~Cyan~{1}~R~ to map', key, a);
                refMap.Add(key, a);
            };

            if (customResolver && !isResolveSet) {
                AppDomain.CurrentDomain.add_AssemblyResolve(@(o, e) {
                    trace('Resolving ~Cyan~{0}~R~', e.Name);
                    var an = new AssemblyName(e.Name);
                    
                    // var key = !an.Name.EndsWith('.resources') ?
                    //     an.Name :
                    //     an.Name.Remove(an.Name.Length - '.resources'.Length);

                    var key = an.Name;

                    if (refMap.ContainsKey(key)) {
                        traceSuccess('Assembly in map');
                        var asm = refMap.get_Item(key) |> Assembly.LoadFrom;
                        traceSuccess('Resolved from map: ~Cyan~{0}~R~', asm);

                        ret asm;
                    } else {
                            traceQuery('Assembly not in map');
                            var asm = Assembly.LoadFrom(e.Name);
                            
                            if (asm != null) {
                                traceSuccess('Assembly loaded: ~Cyan~{0}~R~', asm);
                            } else {
                                traceError('Failed loading assembly: ~Yellow~{0}~R~', e.Name);
                            }

                            ret asm;
                        }
                    });

                    isResolveSet = true;
                }

                ret refAsmPaths->Assembly.LoadFrom;
        },
    };

    installPackage = @(packageId, version)
        nuget
            .createPackageManager()
            .InstallPackage(
                packageId,
                version defined && version != null ? version | parseVersion : null,
                nuget.ignoreDependencies,
                nuget.allowPrereleaseVersions);

    nuget.init();
}();

// Todo: replace with preprocessor looping support
traceInfo = macro(@(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    if (nuget.trace) {
        printInfo(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)
    }
});

traceQuery = macro(@(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    if (nuget.trace) {
        printQuery(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)
    }
});

trace = macro(@(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    if (nuget.trace) {
        print(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)
    }
});

traceSuccess = macro(@(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    if (nuget.trace) {
        printSuccess(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)
    }
});

traceError = macro(@(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    if (nuget.trace) {
        printError(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)
    }
});
_checkCmdParts = macro(@{
    if (parts == null || parts.Count == 0 || parts[0] == null) {
        ret null;
    }
});

_initTrace = macro(@(name) { _initTraceCore(name, var id(trace, name)) });

_initTraceCore = macro(@(name, fullName) {
    fullName = psContext.fullName defined && psContext.fullName ?
        @(fmt) print(
            '{0} Trace: ~Magenta~{1}~R~',
            name,
            $($args.Count)
                0: '[Nothing]',
                1: fmt,
                format(fmt, $args @aq.skip(1))) :
        @() {};
});

var psContext;

var initPSInterop = @{
    var psAsm = load System.Management.Automation;
    using System;
    using System.Collections.ObjectModel;
    using System.Linq;
    using System.Management.Automation;

    psContext = {
        // tracePS: true,
        // tracePSInterop: true,

        psAsm,
        psCollection: Collection[PSObject],
        engine: PowerShell.Create(),
        
        exec: @(command) {
            engine.AddScript(command);
            var r = engine.Invoke() |> psContext.importPSObject;

            ret r;
        },

        execSelect: @(command, selector) command |> exec -> selector,
        execWhere: @(command, predicate) command |> exec -? predicate,

        unwrap: @(obj)
            obj != null &&
            obj.GetType() == PSObject ?
                obj.BaseObject :
                obj,

        importPSObject: @(psObj) {
            _initTrace('PSInterop');
            // tracePSInterop('importPSObject checking enumerable');
            
            if (psObj == null) {
                tracePSInterop('importPSObject returning null');
                ret null;
            } else if (psObj.GetType() != PSObject) {
                if (psObj @isEnumerableOf(PSObject)) {
                    tracePSInterop('importPSObject recursing');
                    ret psObj->importPSObject;
                } else {
                    tracePSInterop('importPSObject returning non-PSObject');
                    ret psObj;
                }
            }

            var o = {
                isPSInterop: true,
                psObject: psObj,
                TypeNames: psObj.TypeNames,
                Properties: psObj.Properties,
                Methods: psObj.Methods,
                Members: psObj.Members,
            };

            _notAccessor = macro(@(n){
                !n.Name.StartsWith('get_') &&
                !n.Name.StartsWith('set_')
            });

            psObj.Properties
                -?(@(p) $(p.Name) 'BaseName', 'VersionInfo': false, _notAccessor(p))
                ->@(p) {
                    try o.{p.Name} = p.Value;
                    catch (e) {
                        tracePSInterop('Error copying {0}: {1}' :: [ p.Name, e.message ]);
                    }
                };

            psObj.Methods
                -?(@(m) _notAccessor(m))
                ->@(m) o.{m.Name} = m.Invoke;

            ret o;
        },

        restorePSObject: @(obj) {
            _initTrace('PSInterop');
            tracePSInterop('Restoring');
            if (obj != null && obj.GetType() == PSObject) {
                tracePSInterop('No action needed');
                ret obj;
            } else if (psContext.isImportedPSObj(obj)) {
                tracePSInterop('Returning psObject property');
                ret obj.psObject;
            } else if (isCollection(obj) &&
                Enumerable.Any(obj) &&
                psContext.isImportedPSObj(obj[0])) {
                tracePSInterop('Recursing');
                ret obj->@(o) o.psObject;
            } else {
                tracePSInterop('No action needed 2');
                //print('Is other');
                ret obj;
            }
        },
        
        isImportedPSObj: @(obj)
            obj != null &&
            obj.isPSInterop defined &&
            obj.isPSInterop &&
            obj.psObject defined,
    };

    psContext.isCommand = @(command) {
        _initTrace('PS');
        command @tracePS('checking for command: {0}');
        var ps = command @format('[bool](Get-Command {0} -ErrorAction SilentlyContinue)');
        ps @tracePS('Running command to perform check: {0}');
        ps |> psContext.engine.AddScript;
        var r;
        try {
            r = psContext.engine.Invoke();
        } catch {
            psContext.engine.Commands.Clear();
            ret false;
        }

        psContext.engine.Commands.Clear();
        r = r.Count > 0 ? r[0].BaseObject : false;
        r @tracePS('Is command: {0}');

        ret r;
    };

    psContext.execPositional = @(parts) {
        _checkCmdParts();
        _initTrace('PS');
        
        var result = {
            parts,
            isItem: false,
            success: true,
            error: null,
        };

        parts[0].GetType() @tracePS('Checking if is command: {0} of type {1}', parts[0]);
        result.isCommand = parts[0] |> psContext.isCommand;
        
        if (result.isCommand) {
            tracePS('Preparing command {0}', parts[0]);
            parts[0] |> psContext.engine.AddCommand;
            parts @aq.skip(1) ->psContext.restorePSObject->psContext.engine.AddArgument;
            tracePS('Invoking PS');
            result.obj = psContext.engine.Invoke();
            tracePS('Clearing command');
            psContext.engine.Commands.Clear();
        } else {
            if (parts.Count > 1) {
                result.error = 'Unknown command';
                tracePS(result.error);
                //result.error = format('Unknown command');
                result.obj = null;
                result.success = false;

                ret result;
            }
            
            tracePS('Getting PS item {0}', parts[0]);
            result.obj = parts[0] |> psContext.getItem;

            if (result.obj.Count != 0) {
                result.isItem = true;
            } else {
                result.isItem = false;
                result.obj = null;
                result.error = 'Unknown command';
                result.success = false;
            }
            

            if ((result.obj |> isCollection) &&
                (result.obj |> Enumerable.Count) == 1) {
                tracePS('Unwrapping PS item');
                result.obj = result.obj[0];
            }
        }

        tracePS('Done executing command: {0}', result |> serialize);

        ret result;
    };

    psContext.getItem = @(path) {
        _initTrace('PS');
        var r;

        try {
            tracePS('Invoking Get-Item {0}'  :: [ path ]);
            'Get-Item' |> psContext.engine.AddCommand;
            path |> psContext.engine.AddArgument;
            r = psContext.engine.Invoke();
            tracePS('Get-Item result: {0}' :: [ r |> serialize ]);
        } catch (e) {
            tracePS('Get-Item failed: {0}' :: [ e.message ]);
            r = null;
        }

        psContext.engine.Commands.Clear();

        ret r;
    };

    psContext.execNamed = @(command, params) {
        if (command == null) {
            ret null;
        }

        command |> psContext.engine.AddCommand;
        params |> keys -> @(n) psContext.engine.AddParameter(n, params.{n});
        var r = psContext.engine.Invoke();
        psContext.engine.Commands.Clear();

        ret r;
    };

    psContext.outString = @(obj) {
        _initTrace('PS');
        tracePS('Dumping result via Out-String ({0})' :: [ obj |> serialize ]);

        if (obj != null && obj.GetType() == AphidObject) {
            using System.Collections.Generic;

            obj = obj.Keys->@() new KeyValuePair[string, string](
                $_,
                @{
                    try ret obj.{$_}.ToString();
                    catch ret '';
                }());
        }

        ret { InputObject: obj } @psContext.psContext.execNamed('Out-String') |> aq.first;
    };

    extend PSObject {
        dynamic funcHandler:@(psObj, name) {
            methods = psObj.Methods-?(@(x) x.Name == name);

            if (methods.Count == 0) {
                fatal('Could not find PowerShell method with name "{0}".' :: [ name ]);
            }

            ret methods[0].Invoke($args @aq.skip(1)) |> psContext.importPSObject;
        },

        toAphidObject: psContext.importPSObject,
    }
};

testPSInterop = macro(@{
    if (!getCommand().EndsWith('PowerShell.alx')) {
        ret null;
    }

    cls();
    var h = @(c) head('Testing PowerShell Script "{0}"' :: [ c ]);
    
    var psExp = 'dir';
    h(psExp);

    using System.IO;

    psExp
        |> psContext.exec
        -?(@(x) x.GetFiles defined)
        ->@(o) o.GetFiles('*Library*', SearchOption.AllDirectories) |> print;

    print();
    psExp = 'dir | Format-Table | Out-String';
    h(psExp);
    psExp |> psContext.exec ->(@()$_.ToString()) -> print;//.ToString() |> print;
});

initPSInterop();

_checkCmdParts = macro(@{
    if (parts == null || parts.Count == 0 || parts[0] == null) {
        ret null;
    }
});

_initTrace = macro(@(name) { _initTraceCore(name, id(trace, name)) });

_initTraceCore = macro(@(name, fullName) {
    fullName;
    fullName = shell.fullName defined && shell.fullName ?
        @(fmt) print(
            '{0} Trace: ~Magenta~{1}~R~',
            name,
            $($args.Count)
                0: '[Nothing]',
                1: fmt,
                format(fmt, $args @aq.skip(1))) :
        @() {};
});

psContext;

initPSInterop = @{
    #'std';
    load System.Management.Automation;
    using System;
    using System.Linq;   
    using System.Management.Automation;

    psObjectType = typeof(PSObject);

    psContext = {
        engine: PowerShell.Create(),
        
        exec: @(command) {
            engine.AddScript(command);
            r;
            r = engine.Invoke() |> psContext.importPSResults;

            ret r;
        },

        execSelect: @(command, selector) command |> exec -> selector,
        execWhere: @(command, predicate) command |> exec -? predicate,

        importPSResults: @(psResults) psResults->importPSObject,

        importPSObject: @(psObj) {
            o;
            o = {PSObject: psObj};

            _notAccessor = macro(@(n){
                !n.Name.StartsWith('get_') &&
                !n.Name.StartsWith('set_')
            });

            psObj.Properties
                -?(@(p) $(p.Name) 'BaseName', 'VersionInfo': false, _notAccessor(p))
                ->@(p) o.{p.Name} = p.Value;

            psObj.Methods
                -?(@(m) _notAccessor(m))
                ->@(m) o.{m.Name} = m.Invoke;

            ret o;
        }
    };

    psContext.isCommand = @(command) {
        _initTrace('PS');
        command @tracePS('checking for command: {0}');
        ps;
        ps = command @format('[bool](Get-Command {0} -ErrorAction SilentlyContinue)');
        ps @tracePS('Running command to perform check: {0}');
        ps |> psContext.engine.AddScript;
        r;
        r = psContext.engine.Invoke();
        psContext.engine.Commands.Clear();
        r = r.Count > 0 ? r[0].BaseObject : false;
        r @tracePS('Is command: {0}');

        ret r;
    };

    psContext.execPositional = @(parts) {
            _checkCmdParts();
            _initTrace('PS');
            isCommand;

            parts[0].GetType() @tracePS('Checking if is command: {0} of type {1}', parts[0]);
            isCommand = parts[0] |> psContext.isCommand;
            r;

            if (isCommand) {
                parts[0] |> psContext.engine.AddCommand;
                parts @aq.skip(1) -> psContext.engine.AddArgument;
                r = psContext.engine.Invoke();
                psContext.engine.Commands.Clear();
            } else {
                if (parts.Count > 1) fatal('Too many parts');
                r = parts[0]|> psContext.getItem;
            }

            if (!isCommand &&
                parts != null &&
                parts.Count >= 1 &&
                (r == null || r.Count == 0) &&
                parts[0].GetType() != typeof(String)) {
                r = parts.Count == 1 ? parts[0] : parts;
            }

        ret r;
    };

    psContext.getItem = @(path) {
        r;

        try {
            'Get-Item' |> psContext.engine.AddCommand;
            path |> psContext.engine.AddArgument;
            r = psContext.engine.Invoke();
        } catch (e) {
            r = null;
        }

        psContext.engine.Commands.Clear();

        ret r;
    };

    psContext.execNamed = @(command, params) {
        if (command == null) {
            ret null;
        }

        command |> psContext.engine.AddCommand;
        params |> keys -> @(n) psContext.engine.AddParameter(n, params.{n});
        r;
        r = psContext.engine.Invoke();
        psContext.engine.Commands.Clear();

        ret r;
    };

    psContext.outString = @(obj) {
        _initTrace('PS');
        tracePS('Dumping result via Out-String');
        { InputObject: obj } @psContext.psContext.execNamed('Out-String')->Console.Write;
    };

    extend PSObject {
        dynamic funcHandler:@(psObj, name) {
            methods = psObj.Methods-?(@(x) x.Name == name);

            if (methods.Count == 0) {
                fatal('Could not find PowerShell method with name "{0}".' :: [ name ]);
            }

            ret methods[0].Invoke($args @aq.skip(1)) |> psContext.importPSResults;
        },

        toAphidObject: psContext.importPSObject,
    }

    testPSInterop();
};

testPSInterop = macro(@{
    if (!getCommand().EndsWith('PowerShell.alx')) {
        ret null;
    }

    cls();
    h = @(c) head('Testing PowerShell Script "{0}"' :: [ c ]);
    
    psExp = 'dir';
    h(psExp);

    using System.IO;

    psExp
        |> psContext.exec
        -?(@(x) x.GetFiles defined)
        ->@(o) o.GetFiles('*Library*', SearchOption.AllDirectories) |> print;

    print();
    psExp = 'dir | Format-Table | Out-String';
    h(psExp);
    psExp |> psContext.exec ->(@()$_.ToString()) -> print;//.ToString() |> print;
});

initPSInterop();

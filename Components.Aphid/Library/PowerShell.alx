_checkCmdParts = macro(@{
    if (parts == null || parts.Count == 0 || parts[0] == null) {
        ret null;
    }
});

_initTrace = macro(@(name) { _initTraceCore(name, id(trace, name)) });

_initTraceCore = macro(@(name, fullName) {
    fullName;
    fullName = psContext.fullName defined && psContext.fullName ?
        @(fmt) print(
            '{0} Trace: ~Magenta~{1}~R~',
            name,
            $($args.Count)
                0: '[Nothing]',
                1: fmt,
                format(fmt, $args @aq.skip(1))) :
        @() {};
});

psContext;
initPSInterop;

initPSInterop = @{
    #'std';
    #'meta';
    psAsm = load System.Management.Automation;
    using System;
    using System.Linq;
    using System.Management.Automation;

    psObject =
        'System.Management.Automation.PSObject'
        |> psAsm.GetType;

    psContext = {
        psAsm,
        psObject,
        
        psObjectCollection = Type
            .GetType('System.Collections.ObjectModel.Collection`1')
            .MakeGenericType([ psObject ]),

        engine: PowerShell.Create(),
        
        exec: @(command) {
            engine.AddScript(command);
            r;
            r = engine.Invoke() |> psContext.importPSObject;

            ret r;
        },

        execSelect: @(command, selector) command |> exec -> selector,
        execWhere: @(command, predicate) command |> exec -? predicate,

        unwrap: @(obj)
            obj != null &&
            obj.GetType() == psContext.psObject ?
                obj.BaseObject :
                obj,

        importPSObject: @(psObj) {
            _initTrace('PSInterop');
            tracePSInterop('importPSObject checking enumerable');
            
            if (psObj @isEnumerableOf(psContext.psObject)) {
                tracePSInterop('importPSObject recursing');
                ret psObj->importPSObject;
            } else if (
                psObj == null ||
                psObj.GetType() != psContext.psObject) {
                tracePSInterop('importPSObject returning');
                ret psObj;
            } 

            //print('converting');
            tracePSInterop('importPSObject converting');

            o;
            o = {
                isPSInterop: true,
                psObject: psObj,
                TypeNames: psObj.TypeNames,
                Properties: psObj.Properties,
                Methods: psObj.Methods,
                Members: psObj.Members,
            };

            _notAccessor = macro(@(n){
                !n.Name.StartsWith('get_') &&
                !n.Name.StartsWith('set_')
            });

            psObj.Properties
                // -?(@(p) $(p.Name) 'Path', 'Company', 'BaseName', 'VersionInfo': false, _notAccessor(p))
                -?(@(p) _notAccessor(p))
                ->@(p) {
                    try o.{p.Name} = p.Value;
                    catch (e) { }
                };

            psObj.Methods
                -?(@(m) _notAccessor(m))
                ->@(m) o.{m.Name} = m.Invoke;

            //setValue(o, psObj);

            ret o;
        },

        restorePSObject: @(obj) {
            _initTrace('PSInterop');
            tracePSInterop('Restoring');
            if (obj != null && obj.GetType() == psObject) {
                tracePSInterop('No action needed');
                ret obj;
            } else if (psContext.isImportedPSObj(obj)) {
                tracePSInterop('Returning psObject property');
                ret obj.psObject;
            } else if (isCollection(obj) &&
                Enumerable.Any(obj) &&
                psContext.isImportedPSObj(obj[0])) {
                tracePSInterop('Recursing');
                ret obj->@(o) o.psObject;
            } else {
                tracePSInterop('No action needed 2');
                //print('Is other');
                ret obj;
            }
        },
        
        isImportedPSObj: @(obj)
            obj != null &&
            obj.isPSInterop defined &&
            obj.isPSInterop &&
            obj.psObject defined,
    };

    psContext.isCommand = @(command) {
        _initTrace('PS');
        command @tracePS('checking for command: {0}');
        ps;
        ps = command @format('[bool](Get-Command {0} -ErrorAction SilentlyContinue)');
        ps @tracePS('Running command to perform check: {0}');
        ps |> psContext.engine.AddScript;
        r;
        try {
            r = psContext.engine.Invoke();
        } catch {
            psContext.engine.Commands.Clear();
            ret false;
        }

        psContext.engine.Commands.Clear();
        r = r.Count > 0 ? r[0].BaseObject : false;
        r @tracePS('Is command: {0}');

        ret r;
    };

    psContext.execPositional = @(parts) {
        _checkCmdParts();
        _initTrace('PS');
        result;
        result = {
            parts,
            isItem: false,
            success: true,
            error: null,
        };

        parts[0].GetType() @tracePS('Checking if is command: {0} of type {1}', parts[0]);
        result.isCommand = parts[0] |> psContext.isCommand;
        
        if (result.isCommand) {
            tracePS('Preparing command {0}', parts[0]);
            parts[0] |> psContext.engine.AddCommand;
            parts @aq.skip(1) ->psContext.restorePSObject->psContext.engine.AddArgument;
            tracePS('Invoking PS');
            result.obj = psContext.engine.Invoke();
            tracePS('Clearing command');
            psContext.engine.Commands.Clear();
        } else {
            if (parts.Count > 1) {
                result.error = 'Unknown command';
                tracePS(result.error);
                //result.error = format('Unknown command');
                result.obj = null;
                result.success = false;

                ret result;
            }
            
            tracePS('Getting PS item {0}', parts[0]);
            result.isItem = true;
            result.obj = parts[0] |> psContext.getItem;

            if ((result.obj |> isCollection) &&
                (result.obj |> Enumerable.Count) == 1) {
                tracePS('Unwrapping PS item');
                result.obj = result.obj[0];
            }
        }

        //if (!result.isCommand &&
            //parts != null &&
            //parts.Count >= 1 &&
            //(result.obj == null || result.obj.Count == 0) &&
            //parts[0].GetType() != typeof(String)) {
            //tracePS('Unwrapping PS result');
            //result.obj = parts.Count == 1 ? parts[0] : parts;
        //}

        tracePS('Done executing command: {0}', result |> serialize);

        ret result;
    };

    psContext.getItem = @(path) {
        r;

        try {
            'Get-Item' |> psContext.engine.AddCommand;
            path |> psContext.engine.AddArgument;
            r = psContext.engine.Invoke();
        } catch (e) {
            r = null;
        }

        psContext.engine.Commands.Clear();

        ret r;
    };

    psContext.execNamed = @(command, params) {
        if (command == null) {
            ret null;
        }

        command |> psContext.engine.AddCommand;
        params |> keys -> @(n) psContext.engine.AddParameter(n, params.{n});
        r;
        r = psContext.engine.Invoke();
        psContext.engine.Commands.Clear();

        ret r;
    };

    psContext.outString = @(obj) {
        _initTrace('PS');
        tracePS('Dumping result via Out-String');
        ret { InputObject: obj } @psContext.psContext.execNamed('Out-String') |> aq.first;
    };

    extend PSObject {
        dynamic funcHandler:@(psObj, name) {
            methods = psObj.Methods-?(@(x) x.Name == name);

            if (methods.Count == 0) {
                fatal('Could not find PowerShell method with name "{0}".' :: [ name ]);
            }

            ret methods[0].Invoke($args @aq.skip(1)) |> psContext.importPSObject;
        },

        toAphidObject: psContext.importPSObject,
    }

    //testPSInterop();
};

testPSInterop = macro(@{
    if (!getCommand().EndsWith('PowerShell.alx')) {
        ret null;
    }

    cls();
    h = @(c) head('Testing PowerShell Script "{0}"' :: [ c ]);
    
    psExp = 'dir';
    h(psExp);

    using System.IO;

    psExp
        |> psContext.exec
        -?(@(x) x.GetFiles defined)
        ->@(o) o.GetFiles('*Library*', SearchOption.AllDirectories) |> print;

    print();
    psExp = 'dir | Format-Table | Out-String';
    h(psExp);
    psExp |> psContext.exec ->(@()$_.ToString()) -> print;//.ToString() |> print;
});

initPSInterop();

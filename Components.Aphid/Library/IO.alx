// ##'Components.Aphid.Library.IOLibrary';
using System.IO;
// var getFsos = @(f, dir, opt) {
//     var filter = '*';
//     var recurse = false;

//     if (opt defined) {
//         if (opt.filter defined) filter = opt.filter;
//         if (opt.recurse defined) recurse = opt.recurse;
//     }

//     ret f(dir, filter, recurse);
// };

// io.dir.getFiles = @getFsos(io.dir.getFilesInternal);
// io.dir.getDirs = @getFsos(io.dir.getDirsInternal);

@ \ (lhs, rhs) lhs @io.end(rhs);
@ .\ (path) path | io.full;

_d = macro(@(f) { Directory.f });
_f = macro(@(f) { File.f });
_p = macro(@(f) { Path.f });
_c = macro(@{ _p(Combine)(lhs, rhs) });
_h = macro(@(f) { pathHelper.f });
_ob = macro(@(o) { _d(GetFiles)(path, pattern defined ? pattern : '*', SearchOption.o) });
@ .* (path, pattern) _ob(TopDirectoryOnly);
@ :* (path, pattern) _ob(AllDirectories);

var io = {
    // pathHelper: Type.GetType('Components.External.PathHelper'),
    dir: _d(Exists),
    file: _f(Exists),

    cd: @(path) path defined ? _d(SetCurrentDirectory)(path) : _d(GetCurrentDirectory)(),

    files: _d(EnumerateFiles),
    dirs: _d(EnumerateDirectories),

    bytes: _f(ReadAllBytes),
    lines: _f(ReadAllLines),
    text: _f(ReadAllText),
    txt: text,

    out: {
        bytes: _f(WriteAllBytes),
        lines: _f(WriteAllLines),
        text: _f(WriteAllText),
        txt: text,
        append: {
            lines: _f(AppendAllLines),
            text: _f(AppendAllText),
            txt: text,
        },
    },

    del: _f(Delete),
    rd: _d(Delete),
    len: @() (new FileInfo($_)).Length,
    size: len,

    parent: _p(GetDirectoryName),
    up: parent,
    name: _p(GetFileName),
    base: _p(GetFileNameWithoutExtension),
    full: _p(GetFullPath),
    attrs: _f(GetAttributes),

    ext: @(pathOrExt, newExt)
        pathOrExt defined ?
            newExt defined ?
                _p(ChangeExtension(newExt, pathOrExt)) :
                _p(GetExtension(pathOrExt)) :
            throw new ArgumentException('Function io.ext() expects one or two arguments'),

    tmp: _p(GetTempPath),
    rnd: _p(GetTempFileName),
    copy: _f(Copy),
    cp: copy,
    move: _f(Move),
    mov: move,
    mv: move,

    created: _f(GetCreationTime),
    date: created,

    accessed: _f(GetLastAccessTime),
    last: accessed,

    modified: _f(GetLastWriteTime),
    touched: modified,

    drives: _d(GetLogicalDrives),

    append: @(rhs, lhs) _c(),
    suffix: append,
    tail: append,
    end: append,

    pre: @(lhs, rhs) _c(),
    prefix: pre,
    prepend: pre,
    head: pre,
    start: pre,

    concat: _p(Combine),
    join: concat,
    
    local: @(f) new Uri(f) @.IsFile,
    remote: @(f) !local(f),

    open: {
        create: _f(Create),
        read: _f(OpenRead),
        write: _f(OpenWrite),
        share: @(path) _f(Open)(
            path,
            FileMode.OpenOrCreate,
            FileAccess.ReadWrite,
            FileShare.ReadWrite),
        
        append: _f(AppendText),
    },

    // entry: @() $args.Count == 0 ? _h(GetEntryDirectory)() : _h(GetEntryPath)($args),
    // executing: @() $args.Count == 0 ? _h(GetExecutingDirectory)() : _h(GetExecutingyPath)($args),
};

var isDir = io.dir;
var isFile = io.file;
var dirExists = io.dir;
var fileExists = io.file;
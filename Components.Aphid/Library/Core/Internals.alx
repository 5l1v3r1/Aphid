using Components.Aphid.Interpreter;
using System.Threading;

_aphid = macro(@{ this.{'$aphid'} defined ? this.{'$aphid'} : null });
var aphid = _aphid();
var aphidLocal = new ThreadLocal[AphidInterpreter](@() _aphid());
var getBlock = @() this.{'$parent'}.{'$block'};

// var aphidExeNames = ;

var parseArgsFor = @{
    var q = getArgQueue();
    
    $args
    @Enumerable.Concat(this.{'$script'} defined ?
        [ ['.alx', '.exe', '' ]
            ->@(e) this.{'$script'}
            |> Path.GetFileNameWithoutExtension
            @()format('{0}{1}', $_, e).ToLower() ] :
        [])
    @Enumerable.Concat([
            [
                '',
                '32',
                '64',
                '.debug',
                '32.debug',
                '64.debug',
                '.binarytrace',
                '.binarytrace32',
                '.binarytrace64',
                'ui',
                '-debug'
            ]
            ->@format('aphid{0}')
            -<(@() [ $_, $_ + 'portable' ])
            -<(@() [ $_, $_ + '.exe' ])
        ])
    
    ->@{
        // $_ @print('Checking for Aphid binaryies: {0}');
        $_ | q.matchPath;
    };
    
    ret q.args;
};

var getArgQueue = @{
    var args = new Queue[ArgToken](Environment.CommandLine |> ArgLexer.GetTokenInfo);
    
    var v = @() args.Count > 0 ? args.Peek().Value : null;
    var matchPath = @{
        var argPath = (@() v().ToLower() |> Path.GetFileName) ?| null;
        // { args: $args, argPath  }| dump;
        
        if ($args =? @(p) p =? @== argPath) {
            // head('Matched');
            // args | dump;
            args.Dequeue();
            // args | dump;
            // head('End matched');
            
            ret true;
        } else {
            ret false;
        }
    };

    
    ret { args, matchPath };
};
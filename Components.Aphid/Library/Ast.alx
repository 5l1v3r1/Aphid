using System;
using Components.Aphid.Lexer;
using Components.Aphid.Parser;
using Components.Aphid.Interpreter;

_op = macro(@(op){ @{ op; } });
_ad = macro(@(op){ @{ code.indent = op * code.tab; } });

ast = {
    op: @() $_.Operator,
    isOp: @(op, node) node.Operator == op,
    isRet: @() $_.Type == nodeType.unOp && ast.isOp(token.return, $_),
    lhs: @(node) node.LeftOperand,
    rhs: @(node) node.RightOperand,
    attr: @(node) node.Attributes[0],

    nodeIs: @(type, node) node.Type == type,
    isId: @(node) node @ast.nodeIs(
        AphidExpressionType.IdentifierExpression),
    
    attrs: @(node) {
        if (!(node |> ast.isId))
        {
            print('ast.attrs expects id node');
            
            ret null;
        }

        ret node.Attributes->@.Identifier;
    },

    depth: 0,
    indent: @() ' ' * ast.depth * 2,
    walk: @(visit, node, context) {
        c = context defined ? context : {};
        c.isRoot = ast.depth == 0;
        c.isBlock = node @is('IEnumerable');
        c.hasChildren = node @has('GetChildren');
        c.isHandled = false;
        visit(node, c);
        next = @(node) ast.walk(visit, node, c);

        if (c.isHandled) ret null;
        
        if (c.isBlock) {
            ast.depth++;
            node->next;
            ast.depth--;
        } else if (c.hasChildren) {  
            node.GetChildren() |> next;
        }
    }
};

nodeType = { };

@{
    id Identifier;
    unOp UnaryOperator;
    binOp BinaryOperator;
    str String;
    call Call;
}.Body->@{
    nodeType.{$_.Attributes[0]} = 
        $_
        @String.Format('AphidExpressionType.{0}Expression')
        evalExp
};

token = {
    return: AphidTokenType.retKeyword
};
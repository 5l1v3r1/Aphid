#'Std';
cls();
#'StringEmitter';
using Components.Aphid.Lexer;
using Components.Aphid.Parser;

e = strEmitter;
e.inNamespace = false;
e.inClass = false;

e.classAspects = {
    public: true,
    partial: true,
};

e.propertyAspects = {
    public: true,
};

e.emitBinaryOperatorExpression = @(exp, isStatement) {
    if (exp.Operator != AphidTokenType.MemberOperator)
        fatal('Invalid op: {0}', exp.Operator);

    parts = exp.GetChildren();
    badParts = parts-?(@() $_.Type != AphidExpressionType.IdentifierExpression);
    
    if (badParts.Count != 0) {
        fatal('Invalid namespace decl: {0}', exp);
    }

    parts->@.Identifier+>@(x, y) x + '.' + y |> beginNamespace;
    //isStatement @print('Binop stmt: {0}, {1}', exp.ToString());
};

e.beginStatement = @(object, isStatement) {
    //print('Beginning stmt');
    //print(inNamespace);
    //print(inClass);
};

e.beginNamespace = @(ns) {
    if (inNamespace) {
        endNamespace();
        append('\r\n');
    }

    append('namespace {0}\r\n{{\r\n', ns);
    indent();
    inNamespace = true;
};

e.endNamespace = @{
    unindent();
    append('}\r\n');
    inNamespace = false;
};

e.beginClass = @(object) {
    inClass = true;
    append(margin());

    if (classAspects.public) append('public ');
    if (classAspects.partial) append('partial ');

    append('class {0}\r\n', object.Identifier.Identifier);
    append(margin());
    append('{\r\n');
    indent();
};

e.endClass = @{
    unindent();
    append('{0}}}\r\n', margin());
    inClass = false;
};

e.emitObjectExpression = @(object, isStatement) {
    beginClass(object, isStatement);
    object.Pairs->emitProperty;
    endClass(object, isStatement);
};

e.emitProperty = @(p) {
    
    attrs = p.LeftOperand @parseAttributes(memberAttrs);
    name = p.LeftOperand.Identifier;
    field = '_' + name;

    append(margin());
    append('private ');
    append(attrs.type + ' ');
    append(field);

    if (p.RightOperand.Type != AphidExpressionType.IdentifierExpression) {
        append(' = ');
        emitExpression(p.RightOperand);
    }

    append(';\r\n\r\n');

    append(margin());
    append(attrs.access + ' ');
    append(attrs.type + ' ');
    append(name);

    append('\r\n');
    appendLine('{');
    indent();

    appendLine('get');
    appendLine('{');
    indent();
    appendLine('return ' + field + ';');
    unindent();
    appendLine('}');
    
    appendLine('set');
    appendLine('{');
    indent();
    appendLine(field + ' = value;');
    
    if (!attrs.silent) {
        appendLine('');
        appendLine('if (PropertyChanged != null)');
        appendLine('{');
        indent();
        appendLine('PropertyChanged(' + 
            'this, ' + 
            'new PropertyChangedEventArgs("' + name + '"))');
        unindent();
        appendLine('}');
    }

    unindent();
    appendLine('}');
    unindent();
    appendLine('}\r\n');
};

e.emitEnd = @{
    if (inClass) endClass();
    if (inNamespace) endNamespace();
};

memberAttrs = @{
    opt access = { private, protected, public };
    type;
};

getLexer = @(stream) {
    l = {
        index: -1,
        token: null,
        count: stream.Count,
        eos: false,
        stream,

        oneOrNone: @(set, def) {
            for (x in set) {
                print('[?] Checking for {0}', x);
                if (x |> match) {
                    ret $_;
                }
            }

            ret def;
        },

        match: @(t) {
            if (token == t) {
                print('[+] token matched');
                next();
                ret true;
            } else {
                print('[-] token not matched');
                ret false;
            }
        },
        
        take: @() {
            t = token;
            if (!eos) next();

            ret t;
        },

        next: @{
            if (index < count) index++;

            if (index != count) {
                token = stream[index];
                print('[+] Next token: {0}', token);
            } else {
                token = null;
                eos = true;
            }

            ret token;
        }
    };

    l.next();

    ret l;
};

lastAttrTree = null;

parseAttributes = @(grammar, exp) {
    if (exp.Attributes.Count == 0)
        ret lastAttrTree;

    print('='*40);
    print('= Attributes');
    print('='*40);

    lexer = exp.Attributes->@.Identifier |> getLexer;
    
    attrTree = {
        access = lexer.oneOrNone(['private', 'public'], 'public'),
        type = lexer.take(),
        silent = lexer.match('silent'),
        success = lexer.eos,
    };

    lastAttrTree = attrTree;

    attrTree |> serialize |> print;

    ret attrTree;
};


@{
    AphidUI.ViewModels;

    class AphidReplViewModel {
        bool IsControlInitialized,
            IsExecuting: 10,
            IsMultiLine,

        string Code,
            Output,
            Status,

        Visibility ExpressionVisibility,
            StatementsVisibility,
            RunVisibility,
            StopVisibility,
            LineOptionVisibility,
    };

    Components.ViewModels;
}.Body |> e.emit;

print();
e.text |> print;

//e.emitObjectExpression();
##'Components.Aphid.Library.StandardLibrary';
#'String';
#'List';
#'Conversion';
using System;

byte = Convert.ToByte;
uint = Convert.ToUInt32;
ulong = Convert.ToUInt64;
sbyte = Convert.ToSByte;
int = Convert.ToInt32;
long = Convert.ToInt64;
float = Convert.ToSingle;
double = Convert.ToDouble;
decimal = Convert.ToDecimal;

getBlock = @() this.{'$parent'}.{'$block'};
_callExp = macro(@(i){ this.{'$frames'}[i].Expression });
getCall = @() _callExp(1);
getArgs = @() _callExp(1).Args;
getArg = @(i) _callExp(1).Args[i];
getIdArg = @(i) _callExp(1).Args[i].Identifier;
idString = @() getArg(0);

format = String.Format;
//_t = @() Cli.WriteLine('~Magenta~Printing {0}~R~', [ $_ ]);
_t = @{};

using System.Linq;
skip = @() Enumerable.Skip($_, 1) |> Enumerable.ToArray;

using Components.External.ConsolePlus;
print = @(fmt, arg0) {
    _s = @() isObject($_) ? $_ : $_.ToString();

    if ($args.Count >= 1 && fmt == null) {
        1 + 1;
        _null Cli.WriteLine('null', []);
    } else if ($args.Count > 1 && isCollection(fmt)) {
        _t('formatted collection');
        args = $args |> skip;
        for (x in fmt) {
            Cli.WriteLine(_s(x), args);
        }
    } else {
        switch ($args.Count) {
            0: {
                _t('blank line');
                Cli.WriteLine();
            }
            1: {
                if (isObject(fmt)) {
                    _t('serialized object');
                    Cli.WriteLine(fmt |> serialize |> Cli.Escape, []);
                } else if (isCollection(fmt)) {                    
                    _t('collection');
                    fmt->@() Cli.WriteLine(_s($_) |> Cli.Escape, []);
                } else {
                    _t('scalar');
                    Cli.WriteLine(_s(fmt), []);
                }
            }
            2: {
                if (arg0 |> isCollection) {
                    _t('formatted collection');
                    Cli.WriteLine(_s(fmt), arg0->@()_s($_));
                } else {
                    _t('single format arg');
                    Cli.WriteLine(_s(fmt), [ arg0 ]);
                }
            }
            default: {
                _t('variadic formatted');
                args = $args |> skip;
                Cli.WriteLine(_s(fmt), args);
            }
        }
    }
};

cls = Console.Clear;
head = @(msg){ Cli.WriteHeader($_, '~|Blue~~White~') };
header = head;

dump = @(o){
    !isObject(o) && toJson defined ? toJson(o) : serialize(o)
    |> Console.WriteLine;
};

exit = @() ($args.Count != 0 ? $_ : 0) |> Environment.Exit;

dumpe = @{ 
    $_ |> dump;
    exit(0);
};

fatal = @{
    f = $args[0];
    a = $args |> skip;
    print('Fatal error: ' + f, a);
    Environment.Exit(0);
};

is = @(name, target)
    target.GetType().GetInterface(name) != null || 
    target.GetType().FullName == name ||
    target.GetType().Name == name;

has = @(name, target)
    target.GetType().GetMethod(name) != null ||
    target.GetType().GetProperty(name) != null;


_get = macro(@(m) { $_.GetType().m() });

_dump = macro(@(m) {
    id(get, m) = @() _get(id(Get, m));
    id(dump, m) = @() ($_ |> id(get, m))->print
});

_dump(Members);
_dump(Properties);
_dump(Methods);

_alias = macro(@(n, n2) {
    id(get, n) = id(get, n2);
    id(dump, n) = id(dump, n2);
});

_alias(Props, Properties);
_alias(Funcs, Methods);

getEntryDir = @() Assembly.GetEntryAssembly().Location |> Path.GetDirectoryName;
getEntryPath = @() $args |> Path.Combine @Path.Combine(getEntryDir());

getEnums = @(name) 0 |> getIdArg |> typeof |> Enum.GetValues;

getFullNames = @(name) this.{'$imports'}->@+('.' + name);

typeof = @(name){
    n = name == null ? getIdArg(0) : name;
    t = (n |> getFullNames)->Type.GetType-?@!= null;
    ret t.Count == 1 ? t[0] : null;
};

using System.Linq;
isObject = keys @> Enumerable.Any;

isCollection = @(x)
    x != null &&
    !isObject(x) &&
    x.GetType() != typeof('String') &&
    x.GetType().GetInterface('IEnumerable') != null;

mix = @(src, dst) {
	for (m in keys(src)) {
		dst.{m} = src.{m};
		mix(src.{m}, dst.{m});
	}
};

getMember = @(obj, path) {	
	val = obj;
	parts = path.split('.');

	for (p in parts) {		
		val = val.{p};
	}

	ret val;
};

loadFile = @(asmFile) asmFile
    |> Path.GetFullPath
    @() $_.Replace('\\', '\\\\')
    @String.Format('load "{0}"')
    |> evalExp;

extend string {
    removeAt: @(x, substring)
        substring
        |> x.IndexOf
        |> x.Remove,
    dec: @(x) x |> Decimal.Parse,
}
// Todo:
// * Extract to separate files e.g. Std.DumpType.alx
// * Create script to apply include inlining to scripts of same 'namespace'
//   e.g. Std.DumpType.alx, Std.Print.alx, Std.alx, etc.
// * Add null extend to cover calls like .dir() to null.
// * Add fork function for Aphid scripts.
// * Add function to hide console.
// * Add API for scheduled tasks.
// * Add API for creating windows services.
// * Add isolation API that copies bins and headers to 
//   unique temp directory and forwards execution for
//   easier autoupdate.
// * Support partial application for custom ops.
// * Support F# style op to func e.g. (+).
//   - Implement at tokenization layer for simplicity.
// * Add whitespace support to main language.
// * Add tailcall elimination.
// * Add immutable keyword that can be used in place of
//   var e.g. immutable foo = 'test';
// * Add private keyword that can be used for locals to
//   prevent automatic resolution outside of function scope e.g.
//   private foo = 'test'; 
//   var func = @{ foo defined @print('defined? {0}') };
//   func();
// * Add private get for locals, accessible normally, set only local.
// * Add protected, other modifiers.
// * Add type decl support to locals e.g. function foo
//   - Ensure type aliases are supported e.g. 
//     AphidFunction -> function, UInt32 -> uint.
//   - Support in AphidObject. Store type name as well as
//     flags for modifiers and validate value/member access.
// * Include and import sequences e.g.
//   using System + Linq, Reflection
//   -> using System.Linq; using System.Reflection
//   using System & Linq, Reflection
//   -> using System; using System.Linq; using System.Reflection
// * Add inline path support to # and load e.g. #..\foo\bar.txt
// * Add pattern support for # and load e.g. load .\Debug\*Mock.dll
// * Make semicolons optional for: ##, #, using, load
// * Update query operators to return lazy IEnumerable
// * Add language integrated PLINQ support
// * Add support for interfaces (and base types if they don't work)
//   to the extension system.
// * Add support for C# extensions in Aphid
// * Generate Aphid function set and API based on PS Cmdlet metadata
// * Global hotkeys with windows hook
//   - Make autocomplete console resolution easily scriptable and 
//     use with global hooks for fast shortcut resolution.
//   - Look into low level console API, further abstract API and 
//     add support for WPF controls.
// * Create UI automation API.
// * Add native PInvoke support.
// * Build AOP API using scripted mutator.
//   - Add function call tracing via expression injection.
//   - Add argument, state, etc. tracing with automatic detailed
//     output for target functions and udner specific conditions
//     e.g. test assert failed.
// * Use IPC to create process singleton API for regular operations
//   that have high init cost but low runtime cost.
//   - Create remote proxy compatible with IPC channel.
// * API based on file system watcher with emphasis on
//   expressiveness and UI.
//   - Use WPF API to make GUI FSW builder/editor and IO 
//     visualization controls.
// * Add naked functions
// * Support <obj>[<string>] style dynamic member access.
// * Verify Dictionary<T,K> support, improve if necessary.
// * Generate three char custom operators.
// * Overhaul query operators.
//   - Add index operator e.g. ->@(x, i) { }
//   - Make configurable by passing context options by
//     special operator.
//     * Ensure option context support is scope and thread safe.
//     * Support async, lazy
##'Components.Aphid.Library.StandardLibrary';
#'String';
#'List';
#'Conversion';
using Components.External.ConsolePlus;
using System;
using System.Linq;
using System.Reflection;

delete print;

var aphid = this.{'$aphid'} defined ? this.{'$aphid'} : null;
var getBlock = @() this.{'$parent'}.{'$block'};
_callExp = macro(@(i){ this.{'$frames'}[i].Expression });
var getCall = @() _callExp(1);
var getArgs = @() _callExp(1).Args;
var getArg = @(i) _callExp(1).Args[i];
var getIdArg = @(i) _callExp(1).Args[i].Identifier;
var idString = @() getArg(0);
var format = string.Format;
var join = string.Join;
var concat = string.Concat;

// Todo: make API for exporting custom ops/type extensions/etc.,
// to other scopes so they can be defined using imports and includes
// without causing scope pollution.
using System.IO;
using System.Text.RegularExpressions;

// Todo: move ops and other common funcs to core header,
// autoload using INI setting.
@ :: (fmt, args) string.Format(fmt, args);
@ :> (fmt, args) $args.Count == 2 ? print(fmt, args) : print(fmt);
@ ?: (string, defaultValue) !String.IsNullOrEmpty(string) ? string : defaultValue;
@ ?| (func, defaultValue) { try ret func(); catch ret defaultValue };
@ ?> (func, defaultValue) @{ try ret func($_); catch ret defaultValue };
@ ?? (value, defaultValue) value != null ? value : defaultValue;
@ <! (func) func ?> false;
@ <! (source, func) $args.Count == 2 ? (source -? (<! func)) : source ?> false;
@ -+ (source, delim) source +> @(x, y) x + delim + y;
@ -| (source, predicate) { _queryBody(Enumerable.Single) };
@ -! (source, predicate) { _queryBody(Enumerable.Any @> @== false) };
@ ~= (input, pattern) _re(IsMatch);
@ ~~ (input, pattern) _re(Matches) @(m) 0..(m #!)->@()m[$_];
@ ~: (input, replace) Regex.Replace(input.ToString(), replace[0], replace[1]);
@ ~? (input, pattern) _rec();
@ ~| (input, pattern) _rec() |> Enumerable.Single;
@ <- (selector, source) source -> selector;
@ ?- (selector, source) source -? selector;
@ <| (target, arg) arg |> target;
@ <@ (f1, f2) f2 @> f1;
@ &\ (file) _in(ReadAllBytes);
@ |\ (file) _in(ReadAllText);
@ \| (text, file) text.ToString() @File.WriteAllText(file.ToString());
@ \& (buffer, file) buffer @File.WriteAllBytes(file.ToString());
@ ?. (lhs, rhs) lhs != null ? lhs.{this.{'$frames'}[0].Expression.RightOperand.Identifier} : null;

@ !! (condition, fatalMessage) {
	if (condition) {
		printCriticalError(fatalMessage); Environment.Exit(0xbad02)
	}
};

_re = macro(@(f) { Regex.f(input.ToString(), pattern.ToString()) });
_rec = macro(@{ input -? @() $_ ~= pattern });

_in = macro(@(f) { file.ToString() |> File.f });

_queryBody = macro(@(filter){
    using System.Linq;
    ret (source -? predicate |> filter);
});

// this.{"$block"}.AddRange(@{
//     using System.Text;
//     var i = 0;
//     cls();
//     [
//         'foobar' ~= 'foo',
//         'hello world' ~= 'foo',
//         'foobar' ~~ 'foo',
//         'hello world' ~~ 'foo',
//         'foobar' ~: [ 'oba', '' ],
//         [ 'foo', 'bar', 'car' ] ~? 'ar' -+ ', ',
//         // 'Hello world' \| 'c:/temp/test.txt',
//         ('\x41\x42\x43\x44'->byte) \& 'c:/temp/test.dat',
//         |\ 'c:/temp/test.txt',
//         &\ 'c:/temp/test.dat',
//         |\ 'c:/temp/test.txt' ~= 'Hello',
//         |\ 'c:/temp/test.txt' ~= 'Hi'
//     ]->serialize->@print('Test {0}: {1}', ++i);
// });

var _t = tracePrint defined ? @() Cli.WriteLine('~Magenta~Printing {0}~R~', [ $_ ]) : @{};

_print(var print, Cli.WriteLine);
_print(var out, Cli.Write);
// Todo: add print*() support for Cli.WriteMessage
// _print(printMsg, Cli.WriteMessage);

var printInfo;
var printQuery;
var printSuccess;
var printError;
var printCriticalError;

_msg = macro(@(msgName) { _msg2(id(print, msgName), id(Write, msgName, Message)) });
_msg2 = macro(@(printName, cliMember) { _print(printName, Cli.cliMember) });
_msg(Info);
_msg(Query);
_msg(Success);
_msg(Error);
_msg(CriticalError);

_print = macro(@(name, write) {
    name = @(fmt, arg0) {
        var skip = @() Enumerable.Skip($_, 1);
        
        if ($args.Count >= 1 && fmt == null) {
            _t('null format');
            _null write('null', []);
        } else if ($args.Count > 1 && isCollection(fmt)) {
            _t('format collection');
            var args = $args |> skip -> @() _na($_);
            for (x in fmt) {
                write(_styleEscaped(x), args);
            }
        } else {
            switch ($args.Count) {
                0: {
                    _t('blank value');
                    write('');
                }
                1: {
                    if (isObject(fmt)) {
                        _t('serialized object');
                        write(fmt |> serialize |> Cli.StyleEscape);
                    } else if (isCollection(fmt)) {
                        _t('collection');
                        fmt->@(x) _styleEscaped(x) |> write;
                    } else {
                        _t('scalar');
                        _scalarFormat(fmt) |> write;
                    }
                }
                2: {
                    if (arg0 != null && (arg0 |> isCollection)) {
                        _t('arg collection');
                        arg0->@() _styleEscaped($_) @write(_f(fmt));
                    } else {
                        _t('single format arg');
                        var a = _styleEscaped(arg0);
                        write(fmt, a);
                    }
                }
                default: {
                    _t('variadic formatted');
                    var args = $args |> skip ->@() _na($_);
                    write(_f(fmt), args);
                }
            }
        }
    };
});

_no = macro(@(x, f) { x == null ? 'null' : x.GetType().IsPrimitive ? x : f });
_n = macro(@(x1, f1) { _no(x1, f1(x1)) });
_na = macro(@(x2) { _no(x2, Cli.StyleEscape(x2)) });

_scalarFormat = macro(@(x4) { x4 == null ? 'null' : x4.ToString() });

_f = macro(@(x5) {
    x5 == null ? 'null' :
    isObject(x5) ? (x5 |> serialize |> Cli.Escape) :
    x5.ToString()
});

_styleEscaped = macro(@(x6) {
    x6 == null ? 'null' :
    isObject(x6) ? (x6 |> serialize |> Cli.StyleEscape) :
    _nonPrimitiveToString(x6)
});

_nonPrimitiveToString = macro(@(value) {
    !value.GetType().IsPrimitive ? value.ToString() : value
});


var cls = Console.Clear;

var fixColors = @{
    Console.ForegroundColor = ConsoleColor.Gray;
    Console.BackgroundColor = ConsoleColor.Black;
};

var console = {
    defaultHeaderStyle: '~|Blue~~White~',
    defaultSubheaderStyle: defaultHeaderStyle,
};

var head = @(msg){ Cli.WriteHeader($_, console.defaultHeaderStyle) };
var header = head;
var subhead = @(msg) { Cli.WriteSubheader(msg, console.defaultSubheaderStyle) };
var subheader = subhead;
console.head = head;
console.header = head;
console.subhead = subhead;
console.subheader = subhead;

var stdScope = this;

if (!(stdScope.dump defined)) {
    stdScope.dump = @(o){
        !isObject(o) && toJson defined ? toJson(o) : serialize(o)
        |> Console.WriteLine;
    };
}

var exit = @() ($args.Count != 0 ? $_ : 0) |> Environment.Exit;

var dumpe = @{ 
    $_ |> dump;
    exit(0);
};

var fatal = @{
    #'Query';
    var msg = 'Fatal error';
    throw $($args.Count) 0: msg, '{0}: {1}' :: [ msg, $args[0] :: ($args @aq.skip(1)) ];
};

var is = @(name, target)
    target.GetType().GetInterface(name) != null || 
    target.GetType().FullName == name ||
    target.GetType().Name == name;

var isEnumerableOf = @(enumerableType, target)
    target != null &&
    isTypeEnumerableOf(enumerableType, target.GetType());

var isTypeEnumerableOf = @(enumerableType, type) {
    var t;

    ret (t = type.GetInterface('IEnumerable`1')) != null &&
        t.GetGenericArguments()[0] == enumerableType;
};

var has = @(name, target)
    target.GetType().GetMethod(name) != null ||
    target.GetType().GetProperty(name) != null;

var expressionColor = {
    comment: '~DarkGreen~',
    modifier: '~DarkCyan~',
    keyword: modifier,
    type: '~Cyan~',
    methodName: '~White~',
    propertyName: methodName,
    eventName: methodName,
    paramName: '~|DarkBlue~~White~',
};

_get = macro(@(method) {
    ([
        //BindingFlags.NonPublic | BindingFlags.Instance,
        //BindingFlags.NonPublic | BindingFlags.Static,
        BindingFlags.Public | BindingFlags.Instance,
        BindingFlags.Public | BindingFlags.Static,
    ]-<obj.GetType().method)
});

_en = macro(@(prefix) {
    !cm.Name.StartsWith(prefix + '_')
    //&& @{ cm.ToString() |> Console.WriteLine; ret true }()
});

_dump = macro(@(m) {
    id(get, m) = @(obj)
        obj == null ? null :
        obj.GetType().Name != 'AphidObject' ? _get(id(Get, m)) :
        (obj |> keys);
    id(dump, m) = @(obj, pattern) {
        using System.Text.RegularExpressions;

        if ($args.Count >= 1 && obj == null) {
            print('Type of null cannot be dumped.');

            ret null;
        }

        var isAphidObject = obj.GetType().Name == 'AphidObject';
        var n = this.{'$frames'}[0].Name;
        var hasPattern = $args.Count == 2;
        var hr = '//' * 40;
        
        print(
            expressionColor.comment + hr + '\r\n// {0}({1}){2}\r\n' + hr + '~R~',
            n,
            obj != null ? obj.GetType().FullName : 'null',
            hasPattern ? ' ' + pattern : '');

        var raw = obj |> id(get, m);

        var members = !isAphidObject ?
            raw-?@(cm) _en('get') && _en('set') && _en('add') && _en('remove') :
            raw;

        var prepared = isAphidObject ? @prepareAphidMember(false) : @prepareClrMember(false);

        var matches = members
            ->(@(x) x |> prepared)
            -?(@(x)
                !hasPattern ||
                Regex.IsMatch(
                    Cli.StyleEscape(x.ToString()),
                    pattern,
                    RegexOptions.IgnoreCase))
            ->(@(o) o)
            @join('\r\n')
            print;
            
        print();
    };
});

var getMembers;
var dumpMembers;
var getProperties;
var dumpProperties;
var getMethods;
var dumpMethods;

_dump(Members);
_dump(Properties);
_dump(Methods);

var memberAccess = { private = 0x1, protected = 0x2, public = 0x4 };

extend RuntimePropertyInfo {
    getAccessor: @(m, access, getSetter) {
        var a = m.GetAccessors(false);

        if (a == null || a.Length == 0) {
            ret null;
        }

        var matches = a
            -? (@(x)
                (getSetter && x.ReturnType == void) ||
                (!getSetter && x.ReturnType != void))
            -? (@(x)
                (access == memberAccess.private && x.IsPrivate) ||
                (access == memberAccess.protected && x.IsFamily) ||
                (access == memberAccess.public && x.IsPublic));

        ret (matches #!) == 0 ? null : matches[0];
    },

    getPrivateAccessor: @(m, getSetter) m.getAccessor(memberAccess.private, getSetter),
    getProtectedAccessor: @(m, getSetter) m.getAccessor(memberAccess.protected, getSetter),
    getPublicAccessor: @(m, getSetter) m.getAccessor(memberAccess.public, getSetter),

    getPrivateSetter: @(m) m.getPrivateAccessor(true),
    getPrivateGetter: @(m) m.getPrivateAccessor(false),
    getProtectedSetter: @(m) m.getProtectedAccessor(true),
    getProtectedGetter: @(m) m.getProtectedAccessor(false),
    getPublicGetter: @(m) m.getPublicAccessor(false),
    getPublicSetter: @(m) m.getPublicAccessor(true),

    hasPrivateSetter: @(m) m.getPrivateAccessor(true) != null,
    hasPrivateGetter: @(m) m.getPrivateAccessor(false) != null,
    hasProtectedSetter: @(m) m.getProtectedAccessor(true) != null,
    hasProtectedGetter: @(m) m.getProtectedAccessor(false) != null,
    hasPublicGetter: @(m) m.getPublicAccessor(false) != null,
    hasPublicSetter: @(m) m.getPublicAccessor(true) != null,
}

_pn = macro(@(t) { useFullNames ? t.FullName : t.Name });

var prepareAphidMember = @(useFullNames, object, key)
    format('{0}={1}', key, object.{key});

var prepareClrMember = @(useFullNames, m)
    format(
        '{0}{1}~R~ ',
        expressionColor.modifier,
        ($(m.GetType())
            RuntimeMethodInfo,
            RuntimeConstructorInfo,            
            ConstructorInfo,
            RuntimeConstructorInfo,
            FieldInfo,
            RuntimeFieldInfo,
            RtFieldInfo:
                m.IsPublic,
            PropertyInfo, RuntimePropertyInfo:
                m.hasPublicGetter(),
            EventInfo, RuntimeEventInfo:
                m.AddMethod != null && m.AddMethod.IsPublic,
            false) ?
            'public' :
            'private') +
    ((m @has('IsStatic')) && m.IsStatic ?
        format('{0}static~R~ ', expressionColor.modifier) :
        '') +
    ($(m.GetType())
        EventInfo, RuntimeEventInfo:
            format('{0}event~R~ ', expressionColor.modifier),
        '') +
    ($(m.GetType())
        ConstructorInfo, RuntimeConstructorInfo:
            format(
                '{0}{1}~R~({2});',
                expressionColor.type,
                _pn(m.DeclaringType),
                _formatParams()),
        MethodInfo, RuntimeMethodInfo:
            format(
                '{0}{1}~R~ {2}{3}~R~({4});',
                expressionColor.type,
                _pn(m.ReturnType),
                expressionColor.methodName,
                m.Name,
                _formatParams()),
        FieldInfo, RuntimeFieldInfo, RtFieldInfo:
            format(
                '{0}{1}~R~ {2}{3}~R~;',
                expressionColor.type,
                _pn(m.FieldType),
                expressionColor.propertyName,
                m.Name),
        PropertyInfo, RuntimePropertyInfo:
            format(
                '{0}{1}~R~ {2}{3}~R~ {{ {4}get~R~;{5} }}',
                expressionColor.type,
                _pn(m.PropertyType),
                expressionColor.propertyName,
                m.Name,
                expressionColor.keyword,
                _formatAutoSet()),
        EventInfo, RuntimeEventInfo:
            format(
                '{0}{1}~R~ {2}{3}~R~;',
                expressionColor.type,
                _pn(m.EventHandlerType),
                expressionColor.eventName,
                m.Name),
        m.ToString());

_formatParams = macro(@{
    m.GetParameters().Length > 0 ?
        m
            .GetParameters()
            ->(@(x) format(
                '{0}{1}~R~ {2}{3}~R~',
                expressionColor.type,
                _pn(x.ParameterType),
                expressionColor.paramName,
                x.Name))
            @join(' ') :
        ''
});

_alias = macro(@(n, n2) {
    id(get, n) = id(get, n2);
    id(dump, n) = id(dump, n2);
});

_formatAutoSet = macro(@{
    m.hasPrivateSetter() ? format(' {0}private set~R~;',
        expressionColor.keyword) :
    m.hasProtectedSetter() ? format(
        ' {0}protected set~R~;',
        expressionColor.keyword) :
    m.hasPublicSetter() ? format(
        ' {0}set~R~;',
        expressionColor.keyword) :
    ''
});

var getProps;
var dumpProps;
var getFuncs;
var dumpFuncs;

_alias(Props, Properties);
_alias(Funcs, Methods);

_aliasExt = macro(@(name, func) {
    extend unknown {
        name: @(o, p)
            $args.Count >= 1 && $args[0] == null ? 'Type of null cannot be dumped.' :
            $args.Count == 1 ? func(o) :
            func(o, p)
    }
});

_aliasExt(dir, dumpMembers);
_aliasExt(props, dumpProps);
_aliasExt(funcs, funcs);


_getAsmDir(Entry);
_getAsmDir(Executing);
_getAsmDir = macro(@(name) { _getAsmDirCore(name, id(Get, name, Assembly)) });

_getAsmDirCore = macro(@(name, fullName) {
    var id(get, name, Dir) = @() Assembly.fullName().Location |> Path.GetDirectoryName;
    var id(get, name, Path) = @() $args |> Path.Combine @Path.Combine(id(get, name, Dir)());
});

var getEnums = @(type) type |> Enum.GetValues;
var getFullNames = @(name) this.{'$imports'}->@+('.' + name);

var map = @(mapping, obj) {
    var m = {};

    mapping |> keys for {
        var k = mapping.{$_};
        m.{$_} = obj.{k} defined ? obj.{k} : null;
    };

    ret m;
};

var isObject = keys @> Enumerable.Any;

var isCollection = @(x)
    x != null &&
    !isObject(x) &&
    x.GetType() != string &&
    x.GetType().GetInterface('IEnumerable') != null;

var mix = @(src, dst) {
	for (m in keys(src)) {
		dst.{m} = src.{m};
		mix(src.{m}, dst.{m});
	}
};

var getMember = @(obj, path) {	
	var val = obj;
	var parts = path.split('.');

	for (p in parts) {		
		val = val.{p};
	}

	ret val;
};

var loadFile = @(asmFile) asmFile
    |> Path.GetFullPath
    @() $_.Replace('\\', '\\\\')
    @format('load "{0}"')
    |> evalExp;

extend string {
    removeAt: @(x, substring)
        substring
        |> x.IndexOf
        |> x.Remove,

    removeAtIndexOf: @(x, value, offset) {
        i;
        ret ((i = x.IndexOf(value)) < 0) ?
            x :
            x.Remove(i + (offset defined ? offset : 0));
    },

    dec: @(x) x |> Decimal.Parse,
}

extend IntPtr {
    toHex: @(p) '0x' + string
        .Format("{0:x}", p.ToInt64())
        .PadLeft(IntPtr.Size == 0x4 ? 0x8 : 0x10, '0'),
}

var getExe = @{
    var asm = Assembly.GetEntryAssembly();

    ret asm != null ? asm.Location : null;
};

var getCommand = @() Environment.CommandLine;
var getCommandLineArgs = @() Environment.GetCommandLineArgs();

var repl = {
    run: @{
        using Components.Aphid.UI;

        var r = new AphidRepl(this.{'$aphid'});

        try r.Run();
        finally r.Dispose();
    }
};

var strOut = @(func){
    using System.Text;
    using System.IO;

    var a = this.{'$aphid'};
    var prev = a.Out;
    var sb = new StringBuilder();
    
    using (var sw = new StringWriter(sb)) {
        a.Out = sw;
        func();
    }

    a.Out = prev;

    ret sb;
};

using System.Collections;

var outStack = new Stack();

var beginOut = @{
    using System.Text;
    using System.IO;

    var a = this.{'$aphid'};
    var sb = new StringBuilder();
    var sw = new StringWriter(sb);
    outStack.Push({ prev: a.Out, sb, sw });
    a.Out = sw;
};

var endOut = @{
    var a = this.{'$aphid'};
    var ctx = outStack.Pop();
    a.Out = ctx.prev;
    ctx.sw.Dispose();
    
    ret ctx.sb;
};
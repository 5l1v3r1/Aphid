##'Components.Aphid.Library.StandardLibrary';
#'String';
#'List';
#'Conversion';
using Components.External.ConsolePlus;
using System;
using System.Linq;
using System.Reflection;

byte = Convert.ToByte;
uint = Convert.ToUInt32;
ulong = Convert.ToUInt64;
sbyte = Convert.ToSByte;
int = Convert.ToInt32;
long = Convert.ToInt64;
float = Convert.ToSingle;
double = Convert.ToDouble;
decimal = Convert.ToDecimal;

aphid = this.{'$aphid'};
getBlock = @() this.{'$parent'}.{'$block'};
_callExp = macro(@(i){ this.{'$frames'}[i].Expression });
getCall = @() _callExp(1);
getArgs = @() _callExp(1).Args;
getArg = @(i) _callExp(1).Args[i];
getIdArg = @(i) _callExp(1).Args[i].Identifier;
idString = @() getArg(0);
format = String.Format;
join = String.Join;

@ =< (selector, source) source -> selector;
@ <| (target, arg) arg |> target;
@ :: (fmt, args) String.Format(fmt, args);
@ :> (fmt, args) $args.Count == 2 ? print(fmt, args) : print(fmt);

_t = tracePrint defined ? @() Cli.WriteLine('~Magenta~Printing {0}~R~', [ $_ ]) : @{};

skip = @() Enumerable.Skip($_, 1) |> Enumerable.ToArray;

print = @(fmt, arg0) {
    _no = macro(@(x, f) { x == null ? 'null' : f });
    _n = macro(@(x1, f1) { _no(x1, f1(x1)) });
    _na = macro(@(x2) { _no(x2, Cli.StyleEscape(x2)) });
    _oc = macro(@(x3, r) { _no(x3, isObject(x3) ? r : x3.ToString()) });
    
    _scalarFormat = macro(@(x4) { x4 == null ? 'null' : x4.ToString() });
    
    _f = macro(@(x5) { 
        x5 == null ? 'null' :
        isObject(x5) ? (x5 |> serialize |> Cli.Escape) :
        !x5.GetType().IsPrimitive ? x5.ToString() :
        x5
    });
    
    _styleEscaped = macro(@(x6) {
        x6 == null ? 'null' :
        isObject(x6) ? (x6 |> serialize |> Cli.StyleEscape) :
        !x6.GetType().IsPrimitive ? x6.ToString() :
        x6
    });

    if ($args.Count >= 1 && fmt == null) {
        _t('null format');
        _null Cli.WriteLine('null', []);
    } else if ($args.Count > 1 && isCollection(fmt)) {
        _t('format collection');
        args = $args |> skip -> @() _na($_);
        for (x in fmt) {
            Cli.WriteLine(_styleEscaped(x), args);
        }
    } else {
        switch ($args.Count) {
            0: {
                _t('blank line');
                Cli.WriteLine();
            }
            1: {
                if (isObject(fmt)) {
                    _t('serialized object');
                    Cli.WriteLine(fmt |> serialize |> Cli.StyleEscape);
                } else if (isCollection(fmt)) {                    
                    _t('collection');
                    fmt->@(x) _styleEscaped(x) |> Cli.WriteLine;
                } else {
                    _t('scalar');
                    _scalarFormat(fmt) |> Cli.WriteLine;
                }
            }
            2: {
                if (arg0 != null && (arg0 |> isCollection)) {
                    _t('arg collection');
                    arg0->@() _styleEscaped($_) @Cli.WriteLine(_f(fmt));
                } else {
                    _t('single format arg');
                    a = _styleEscaped(arg0);                    
                    Cli.WriteLine(fmt, a);
                }
            }
            default: {
                _t('variadic formatted');
                args = $args |> skip ->@() _na($_);
                Cli.WriteLine(_f(fmt), args);
            }
        }
    }
};

cls = Console.Clear;
head = @(msg){ Cli.WriteHeader($_, '~|Blue~~White~') };
header = head;

dump = @(o){
    !isObject(o) && toJson defined ? toJson(o) : serialize(o)
    |> Console.WriteLine;
};

exit = @() ($args.Count != 0 ? $_ : 0) |> Environment.Exit;

dumpe = @{ 
    $_ |> dump;
    exit(0);
};

fatal = @{
    f = $args[0];
    a = $args |> skip;
    print('Fatal error: ' + f, a);
    Environment.Exit(0);
};

is = @(name, target)
    target.GetType().GetInterface(name) != null || 
    target.GetType().FullName == name ||
    target.GetType().Name == name;

has = @(name, target)
    target.GetType().GetMethod(name) != null ||
    target.GetType().GetProperty(name) != null;

expressionColor = {
    comment: '~DarkGreen~',
    modifier: '~DarkCyan~',
    keyword: modifier,
    type: '~Cyan~',
    methodName: '~White~',
    propertyName: methodName,
    eventName: methodName,
    paramName: '~|DarkBlue~~White~',
};

_get = macro(@(method) {
    ([
        //BindingFlags.NonPublic | BindingFlags.Instance,
        //BindingFlags.NonPublic | BindingFlags.Static,
        BindingFlags.Public | BindingFlags.Instance,
        BindingFlags.Public | BindingFlags.Static,
    ]-<obj.GetType().method)
});

_en = macro(@(prefix) { !cm.Name.StartsWith(prefix + '_') });

_dump = macro(@(m) {
    id(get, m) = @(obj) _get(id(Get, m));
    id(dump, m) = @(obj) {
        n;
        n = this.{'$frames'}[0].Name;
        print(
            expressionColor.comment +
                '//' * 40 +
                '\r\n// {0}({1})\r\n' +
                '//' * 40 +
                '~R~',
            n,
            obj != null ? obj.GetType().FullName : 'null');
        (obj |> id(get, m))
            -?(@(cm) _en('get') && _en('set') && _en('add') && _en('remove'))
            ->printMember;

        print();
    };
});

_dump(Members);
_dump(Properties);
_dump(Methods);

memberAccess = { private = 0x1, protected = 0x2, public = 0x4 };

extend RuntimePropertyInfo {
    getAccessor: @(m, access, getSetter) {
        a;
        matches;
        a = m.GetAccessors(false);

        if (a == null || a.Length == 0) {
            ret null;
        }

        matches = a
            -? (@(x)
                (getSetter && x.ReturnType == typeof(Void)) ||
                (!getSetter && x.ReturnType != typeof(Void)))
            -? (@(x)
                (access == memberAccess.private && x.IsPrivate) ||
                (access == memberAccess.protected && x.IsFamily) ||
                (access == memberAccess.public && x.IsPublic));

        ret matches.Count == 0 ? null : matches[0];
    },

    getPrivateAccessor: @(m, getSetter) m.getAccessor(memberAccess.private, getSetter),
    getProtectedAccessor: @(m, getSetter) m.getAccessor(memberAccess.protected, getSetter),
    getPublicAccessor: @(m, getSetter) m.getAccessor(memberAccess.public, getSetter),

    getPrivateSetter: @(m) m.getPrivateAccessor(true),
    getPrivateGetter: @(m) m.getPrivateAccessor(false),
    getProtectedSetter: @(m) m.getProtectedAccessor(true),
    getProtectedGetter: @(m) m.getProtectedAccessor(false),
    getPublicGetter: @(m) m.getPublicAccessor(false),
    getPublicSetter: @(m) m.getPublicAccessor(true),

    hasPrivateSetter: @(m) m.getPrivateAccessor(true) != null,
    hasPrivateGetter: @(m) m.getPrivateAccessor(false) != null,
    hasProtectedSetter: @(m) m.getProtectedAccessor(true) != null,
    hasProtectedGetter: @(m) m.getProtectedAccessor(false) != null,
    hasPublicGetter: @(m) m.getPublicAccessor(false) != null,
    hasPublicSetter: @(m) m.getPublicAccessor(true) != null,
}

_pn = macro(@(t) { useFullNames ? t.FullName : t.Name });

printMember = @(m, useFullNames) {
    useFullNames = useFullNames defined ? useFullNames : false;

    format(
        '{0}{1}~R~ ',
        expressionColor.modifier,
        ($(m.GetType())
            typeof(RuntimeMethodInfo),
            typeof(RuntimeConstructorInfo),            
            typeof(ConstructorInfo),
            typeof(RuntimeConstructorInfo),
            typeof(FieldInfo),
            typeof(RuntimeFieldInfo),
            typeof(RtFieldInfo):
                m.IsPublic,
            typeof(PropertyInfo), typeof(RuntimePropertyInfo):
                m.hasPublicGetter(),
            typeof(EventInfo), typeof(RuntimeEventInfo):
                m.AddMethod != null && m.AddMethod.IsPublic,
            false) ?
            'public' :
            'private') +
    ((m @has('IsStatic')) && m.IsStatic ?
        format('{0}static~R~ ', expressionColor.modifier) :
        '') +
    ($(m.GetType())
        typeof(EventInfo), typeof(RuntimeEventInfo):
            format('{0}event~R~ ', expressionColor.modifier),
        '') +
    ($(m.GetType())
        typeof(ConstructorInfo), typeof(RuntimeConstructorInfo):
            format(
                '{0}{1}~R~({2});',
                expressionColor.type,
                _pn(m.DeclaringType),
                formatParams(m, useFullNames)),
        typeof(MethodInfo), typeof(RuntimeMethodInfo):
            format(
                '{0}{1}~R~ {2}{3}~R~({4});',
                expressionColor.type,
                _pn(m.ReturnType),
                expressionColor.methodName,
                m.Name,
                formatParams(m, useFullNames)),
        typeof(FieldInfo), typeof(RuntimeFieldInfo), typeof(RtFieldInfo):
            format(
                '{0}{1}~R~ {2}{3}~R~;',
                expressionColor.type,
                _pn(m.FieldType),
                expressionColor.propertyName,
                m.Name),
        typeof(PropertyInfo), typeof(RuntimePropertyInfo):
            format(
                '{0}{1}~R~ {2}{3}~R~ {{ {4}get~R~;{5} }}',
                expressionColor.type,
                _pn(m.PropertyType),
                expressionColor.propertyName,
                m.Name,
                expressionColor.keyword,
                m |> formatAutoSet),
        typeof(EventInfo), typeof(RuntimeEventInfo):
            format(
                '{0}{1}~R~ {2}{3}~R~;',
                expressionColor.type,
                _pn(m.EventHandlerType),
                expressionColor.eventName,
                m.Name),
        m.ToString())
    |> print;
};

formatParams = @(m, useFullNames) m.GetParameters().Length > 0 ?
    m
        .GetParameters()
        ->(@(x) format(
            '{0}{1}~R~ {2}{3}~R~',
            expressionColor.type,
            _pn(x.ParameterType),
            expressionColor.paramName,
            x.Name))
        +>@(x, y) x + ' ' + y :
    '';

_alias = macro(@(n, n2) {
    id(get, n) = id(get, n2);
    id(dump, n) = id(dump, n2);
});

formatAutoSet = @(m) 
    m.hasPrivateSetter() ? format(
        ' {0}private set~R~;',
        expressionColor.keyword) :
    m.hasProtectedSetter() ? format(
        ' {0}protected set~R~;',
        expressionColor.keyword) :
    m.hasPublicSetter() ? format(
        ' {0}set~R~;',
        expressionColor.keyword) :
    '';

_alias(Props, Properties);
_alias(Funcs, Methods);

getEntryDir = @() Assembly.GetEntryAssembly().Location |> Path.GetDirectoryName;
getEntryPath = @() $args |> Path.Combine @Path.Combine(getEntryDir());
getEnums = @(name) 0 |> getIdArg |> typeof |> Enum.GetValues;
getFullNames = @(name) this.{'$imports'}->@+('.' + name);

typeof = @(name){
    n = name == null ? getIdArg(0) : name;
    t = (n |> getFullNames)->Type.GetType-?@!= null;
    ret t.Count == 1 ? t[0] : null;
};

map = @(mapping, obj) {
    m = {};

    mapping |> keys for {
        k = mapping.{$_};
        m.{$_} = obj.{k} defined ? obj.{k} : null;
    };

    ret m;
};

isObject = keys @> Enumerable.Any;

isCollection = @(x)
    x != null &&
    !isObject(x) &&
    x.GetType() != typeof('String') &&
    x.GetType().GetInterface('IEnumerable') != null;

mix = @(src, dst) {
	for (m in keys(src)) {
		dst.{m} = src.{m};
		mix(src.{m}, dst.{m});
	}
};

getMember = @(obj, path) {	
	val = obj;
	parts = path.split('.');

	for (p in parts) {		
		val = val.{p};
	}

	ret val;
};

loadFile = @(asmFile) asmFile
    |> Path.GetFullPath
    @() $_.Replace('\\', '\\\\')
    @String.Format('load "{0}"')
    |> evalExp;

extend string {
    removeAt: @(x, substring)
        substring
        |> x.IndexOf
        |> x.Remove,
    dec: @(x) x |> Decimal.Parse,
}

extend IntPtr {
    toHex: @(p) '0x' + String
        .Format("{0:x}", p.ToInt64())
        .PadLeft(IntPtr.Size == 0x4 ? 0x8 : 0x10, '0'),
}
using System.Reflection;
using System.Reflection.Emit;

var createAsm;
var createProgram;
var importOpcodes;
var asmIL;
var execIL;
var execILBlock;
var ilImportScope = this;

@{
    #'Std';
    #'Meta';

    using System;
    using System.Threading;

    createAsm = @(name) {
        var asm = AppDomain.CurrentDomain
            .DefineDynamicAssembly(
                new AssemblyName(name),
                AssemblyBuilderAccess.Run | AssemblyBuilderAccess.Save);

        var module = name |> asm.DefineDynamicModule;

        ret {
            asm,
            module,
            setEntryPoint: asm.SetEntryPoint,
            createEntryPoint: @(ilCallback) {
                var type = module.DefineType(
                    'Program',
                    TypeAttributes.Class | TypeAttributes.Public);

                var method = type.DefineMethod(
                    'Main',
                    MethodAttributes.HideBySig |
                        MethodAttributes.Public |
                        MethodAttributes.Static,
                    void,
                    [ string.MakeArrayType() ]);

                method.GetILGenerator() |> ilCallback;
                type.CreateType();
                method |> asm.SetEntryPoint;
            },
            save: asm.Save,
        
        };
    };

    createProgram = @(asmName, ilCallback) {
        var asm = asmName |> createAsm;
        ilCallback |> asm.createEntryPoint;
        asmName |> asm.save;
    };

    var scope = ilImportScope;

    importOpcodes = @()
        OpCodes
            .GetFields()
            ->(@.Name)
            ->(@(n) scope.{n} = n @String.Format('OpCodes.{0}') |> evalExp);

    asmIL = @(il) {
        var emit = @(instruction) {
            if (instruction.isCall()) {
                ret emitGenerate(
                    instruction.FunctionExpression,
                    instruction.Args->@()$_.ToString());
            } else if (instruction.isString()) {
                ret emitLsdstr(instruction);
            } else if (instruction.isId()) {
                ret emitGenerate(instruction.ToString());
            }
        };

        var emitLsdstr = @(str) emitGenerate('Ldstr', [ str.ToString() ]);
        var emitMnemonic = @(mnemonic) { };

        var emitGenerate = @(mnemonic, args)
            $args.Count > 1 && (args |> Enumerable.Any) ?
                format('$_.Emit(OpCodes.{0}, {1});', mnemonic, args @join(', ')) :
                format('$_.Emit(OpCodes.{0});', mnemonic);

        ret il->emit @join('\r\n') @format('@{{\r\n{0}\r\n}}') |> evalExp;
    };

    var ilModuleSync = new Object();
    var ilModuleName = null;
    var ilModule = null;

    var getILModule = @{
        Monitor.Enter(ilModuleSync);

        try {
            if (ilModule == null) {
                ilModuleName = 'InlineIL_' + Guid.NewGuid().ToString();

                var asm = AppDomain.CurrentDomain.DefineDynamicAssembly(
                    new AssemblyName(ilModuleName),
                    AssemblyBuilderAccess.Run);

                ilModule = name |> asm.DefineDynamicModule;
            }

            ret ilModule;
        } finally {
            Monitor.Exit(ilModuleSync);
        }

        
    };

    execILBlock = @(il) {
        var methodName = 'Test';

        var type = getILModule().DefineType(
            'InlineIL_' + Guid.NewGuid().ToString(),
            TypeAttributes.Class | TypeAttributes.Public);

        var method = type.DefineMethod(
            methodName,
            MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static,
            void,
            [  ]);

        method.GetILGenerator() @{
            importOpcodes();
            $_ |> il;
        };

        type.CreateType();

        ret type.GetMethod(methodName).Invoke(null, []);
    };

    execIL = asmIL @> execILBlock;
}();

delete ilImportScope;
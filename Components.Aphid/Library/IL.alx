using System.Reflection;
using System.Reflection.Emit;

createAsm;
createProgram;
importOpcodes;
asmIL;
execIL;
execILBlock;

@{
    #'Std';
    #'Meta';

    using System;
    using System.Threading;

    createAsm = @(name) {
        asm = AppDomain.CurrentDomain
            .DefineDynamicAssembly(
                new AssemblyName(name),
                AssemblyBuilderAccess.Run | AssemblyBuilderAccess.Save);

        module = name |> asm.DefineDynamicModule;

        ret {
            asm,
            module,
            setEntryPoint: asm.SetEntryPoint,
            createEntryPoint: @(ilCallback) {
                type = module.DefineType(
                    'Program',
                    TypeAttributes.Class | TypeAttributes.Public);

                method = type.DefineMethod(
                    'Main',
                    MethodAttributes.HideBySig |
                        MethodAttributes.Public |
                        MethodAttributes.Static,
                    typeof(Void),
                    [ typeof(String).MakeArrayType() ]);

                method.GetILGenerator() |> ilCallback;
                type.CreateType();
                method |> asm.SetEntryPoint;
            },
            save: asm.Save,
        
        };
    };

    createProgram = @(asmName, ilCallback) {
        asm = asmName |> createAsm;
        ilCallback |> asm.createEntryPoint;
        asmName |> asm.save;
    };

    importOpcodes = @()
        (OpCodes |> typeof)
            .GetFields()
            ->(@.Name)
            ->(@(n) this.{'$parent'}.{'$parent'}.{n} =
                n @String.Format('OpCodes.{0}') |> evalExp);

    asmIL = @(il) {
        emit;
        emitMnemonic;
        emitGenerate;

        emit = @(instruction) {
            if (instruction.isCall()) {
                ret emitGenerate(
                    instruction.FunctionExpression,
                    instruction.Args->@()$_.ToString());
            } else if (instruction.isString()) {
                ret emitLsdstr(instruction);
            } else if (instruction.isId()) {
                ret emitGenerate(instruction.ToString());
            }
        };

        emitLsdstr = @(str)
            emitGenerate('Ldstr', [ str.ToString() ]);

        emitMnemonic = @(mnemonic) {
        };

        emitGenerate = @(mnemonic, args)
            $args.Count > 1 && (args |> Enumerable.Any) ?
                format('$_.Emit(OpCodes.{0}, {1});', mnemonic, args @join(', ')) :
                format('$_.Emit(OpCodes.{0});', mnemonic);

        ret il->emit @join('\r\n') @format('@{{\r\n{0}\r\n}}') |> evalExp;
    };

    var ilModuleSync = new Object();
    var ilModuleName = null;
    var ilModule = null;

    var getILModule = @{
        Monitor.Enter(ilModuleSync);

        try {
            if (ilModule == null) {
                ilModuleName = 'InlineIL_' + Guid.NewGuid().ToString();

                var asm = AppDomain.CurrentDomain.DefineDynamicAssembly(
                    new AssemblyName(ilModuleName),
                    AssemblyBuilderAccess.Run);

                ilModule = name |> asm.DefineDynamicModule;
            }

            ret ilModule;
        } finally {
            Monitor.Exit(ilModuleSync);
        }

        
    };

    execILBlock = @(il) {
        var methodName = 'Test';

        var type = getILModule().DefineType(
            'InlineIL_' + Guid.NewGuid().ToString(),
            TypeAttributes.Class | TypeAttributes.Public);

        var method = type.DefineMethod(
            methodName,
            MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static,
            typeof(Void),
            [  ]);

        method.GetILGenerator() @{
            importOpcodes();
            $_ |> il;
        };

        type.CreateType();

        ret type.GetMethod(methodName).Invoke(null, []);
    };

    execIL = asmIL @> execILBlock;
}();
using Components.Aphid.TypeSystem;
using Components.Aphid.Serialization;
using System;

if (!this.{'$aphid'}.AsmBuilder.IsTypeDefined('RemoteProxy')) {
    class RemoteProxy { AphidFunction Connect, Guid RemoteId, string BasePath };
}

extend RemoteProxy {
    Eval: @(s, code) code |> remote._remoteTable.{s.RemoteId}.eval,

    dynamic handle: @(s, name) {
        using System.Text;
        var sb = new StringBuilder();
        sb.Append('ret ');
        sb.Append(!String.IsNullOrEmpty(s.BasePath) ? s.BasePath + '.' + name : name);
        sb.Append('(\r\n    ');
        var firstArg = true;

        $args @aq.skip(1) -> serialize ->@(s) {
            if (firstArg) {
                firstArg = false;
            } else {
                sb.Append(', ');
            }

            s |> sb.Append;
        };

        sb.AppendLine(');');
        var resp = sb.ToString() |> remote._remoteTable.{s.RemoteId}.eval;
        
        ret resp != null && resp.result defined ?
            resp.result :
            { success: false, result: 'Error', obj: resp };
    }
}

var remote = null;

@{
    using System;
    using System.IO;
    using System.Net;
    using System.Net.Sockets;
    using System.Text;
    #'Threading';
    #'Compression';
    //#'Query';
    //#'Std';
    
    extend TcpClient {
        isConnected: @(c) c.Client.Poll(0, SelectMode.SelectRead) && c.Client.Available != 0,
    }
    //var traceRemoting = true;
    var _rt = traceRemoting defined ? Cli.WriteLine : @{ };
    var utf8 = new UTF8Encoding();

    var createClient = @(tcp) ({
        socket: tcp,
        stream: tcp.GetStream(),
        
        read: @{
            var reader = new BinaryReader(tcp.GetStream());
            var len = reader.ReadUInt32();
            _rt('Receiving {0:n0} bytes', len);
            var buf = len |> Convert.ToInt32 |> reader.ReadBytes |> remote.decode;
            _rt('{0:n0} bytes read', buf.Length);

            ret AphidObject.Scalar(buf |> utf8.GetString);
        },

        write: @(b) {
            var buf = b |> utf8.GetBytes |> remote.encode;
            var writer = new BinaryWriter(tcp.GetStream());
            [ buf.Length |> Convert.ToUInt32, buf ]->writer.Write;
        },
    });

    _isAlive = macro(@(client) { client.Connected });

    _initSerializer = macro(@(a){
        a.Serializer.QuoteToStringResults = true;
        a.Serializer.IgnoreFunctions = true;
        a.Serializer.IgnoreSpecialVariables = true;
    });

    remote = {
        port: 0x5230,

        encode: deflate.compress,
        decode: deflate.decompress,

        listen: @(port){
            var actualPort = port ?? remote.port;
            _rt('Creating listener on port {0}', actualPort);
            var ctx = { listener: new TcpListener(actualPort), clients: [] };
            _rt('Starting listener');
            var l = ctx.listener;
            ctx.listener.Start();
            _initSerializer(this.{'$aphid'});

            ctx.listenThread = thread(@{
                var aphid = this.{'$aphid'};
                
                while (true) {
                    _rt('Waiting for client');

                    try {
                        var tcp = ctx.listener.AcceptTcpClient();
                        _rt('Client connected');
                        var c = createClient(tcp);

                        c.thread = thread(@{
                            var buffer;
                            var resp;
                            _rt('Creating client thread');

                            try {
                                while (c.socket.Connected) {
                                    try buffer = c.read();
                                    catch (e) {
                                        _rt('Error reading buffer: {0}', e.message);
                                        continue;
                                    }

                                    _rt('Buffer: ~Cyan~{0}~R~', buffer);

                                    try {
                                        var o = buffer |> aphid.InterpretStream;
                                        resp = { result: o } |> serialize;
                                    } catch (e) {
                                        _rt('Error serializating response: {0}', e.message);
                                        this |> serialize |> c.write;
                                    }

                                    resp |> c.write;
                                }
                            } catch (e) {
                                _rt('Client connection error: {0}', e.message);
                            }

                            _rt('Client disconnected');
                        });

                        ctx.clients.add(c);
                    } catch (e) {
                        _rt('Error accepting client: {0}', e.message);
                    }
                }            
            });

            ret ctx;
        },

        connect: @(server, port){
            if (!(server defined) || server == null) {
                fatal('Server must be specified');
            }

            _rt('Connecting to remote session {0}', server);
            var tcp = new TcpClient();
            tcp.Connect(server, port ?? remote.port);        
            var client = createClient(tcp);

            client.eval = @(exp) {
                _rt('Writing command: ~Cyan~{0}~R~', exp.Replace('~', '~~'));
                write(exp);
                _rt('Reading command');
                var buf = read();
                _rt('Server response:\r\n~Magenta~{0}~R~\r\n\r\n', buf |> Cli.StyleEscape);
                ret buf |> deserialize;
            };

            _rt('Connected to remote session');

            ret client;
        },
        _remoteTable: {},
        
        connectProxy: @(server, port) {
            var proxy = new RemoteProxy();
            proxy.RemoteId = Guid.NewGuid();
            remote._remoteTable.{proxy.RemoteId} = remote.connect(server, port);

            ret proxy;
        }
    };
}();
using System;
using Components.Aphid.Parser;

parse = @(code) AphidParser.Parse(code, false);
parseExp = @(exp) parse(exp)[0];

parseFunc = @(code) {
    f = @{ };
    f.Body.Clear();
    (code |> parse)->f.Body.Add;
    
    ret f;
};

evalBlock = @(code) parseFunc(code)();
evalExp = @(code) parseFunc('ret ' + code)();

getEnums = @(name) 0 |> getIdArg |> typeof |> Enum.GetValues;
getFullNames = @(name) this.{'$imports'}->@+('.' + name);

_callExp = macro(@(i){ this.{'$frames'}[i].Expression });
getCall = @() _callExp(1);
getArgs = @() _callExp(1).Args;
getArg = @(i) _callExp(1).Args[i];
getIdArg = @(i) _callExp(1).Args[i].Identifier;
idString = @() getArg(0);

typeof = @(name){
    n = name == null ? getIdArg(0) : name;
    t = (n |> getFullNames)->Type.GetType-?@!= null;
    ret t.Count == 1 ? t[0] : null;
};

makeFluent = @(obj) {
    n = getIdArg(0);
    (obj |> reflection.members)
    -> (@() obj.{$_})
    -? (@has('Body'))
    -> (@{
        using System.Linq;
        if (($_.Body.Count) == 0 ||
            ($_.Body |> Enumerable.Last |> ast.isRet @== false))
            'ret ' + n  |> parseExp |> $_.Body.Add;
    });

    ret obj;
};

